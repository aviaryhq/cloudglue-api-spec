{
  "openapi": "3.0.0",
  "info": {
    "title": "Cloudglue API",
    "description": "API for Cloudglue",
    "license": {
      "name": "Apache License 2.0",
      "url": "https://www.apache.org/licenses/LICENSE-2.0"
    },
    "version": "0.6.2"
  },
  "servers": [
    {
      "url": "https://api.cloudglue.dev/v1"
    }
  ],
  "security": [
    {
      "bearerAuth": []
    }
  ],
  "paths": {
    "/tags": {
      "post": {
        "tags": ["Tags"],
        "summary": "Create a new tag",
        "operationId": "createTag",
        "description": "Create a new tag",
        "requestBody": {
          "description": "Tag creation parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateVideoTagRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Tag created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoTag"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or missing required label/value",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Resource limits exceeded (total tags per file or segment)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Tags"],
        "summary": "List all tags",
        "operationId": "listTags",
        "description": "List all tags",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Filter tags by type: 'file' or 'segment'",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["file", "segment"]
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of tags to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of tags to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of tags",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListVideoTagsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/tags/{tag_id}": {
      "get": {
        "tags": ["Tags"],
        "summary": "Get a tag",
        "operationId": "getTag",
        "description": "Get a tag",
        "parameters": [
          {
            "name": "tag_id",
            "in": "path",
            "required": true,
            "description": "The ID of the tag",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tag",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoTag"
                }
              }
            }
          },
          "404": {
            "description": "Tag not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Tags"],
        "summary": "Delete a tag",
        "operationId": "deleteTag",
        "description": "Delete a tag",
        "parameters": [
          {
            "name": "tag_id",
            "in": "path",
            "required": true,
            "description": "The ID of the tag",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Tag deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "Unique identifier for the tag"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Tag not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Tags"],
        "summary": "Update a tag",
        "operationId": "updateTag",
        "description": "Update a tag",
        "parameters": [
          {
            "name": "tag_id",
            "in": "path",
            "required": true,
            "description": "The ID of the tag",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Tag update parameters. At least one of label or value is required.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateVideoTagRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Tag updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VideoTag"
                }
              }
            }
          }
        }
      }
    },
    "/extract": {
      "post": {
        "tags": ["Extract"],
        "summary": "Create a new extract job",
        "operationId": "createExtract",
        "description": "Extract structured data from a video",
        "requestBody": {
          "description": "Extract job parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewExtract"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Extract"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or missing required prompt/schema",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Extract job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Monthly extract jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Extract"],
        "summary": "List all extract jobs",
        "operationId": "listExtracts",
        "description": "List all extract jobs with optional filtering",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of extract jobs to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of extract jobs to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter extract jobs by status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "pending",
                "processing",
                "completed",
                "failed",
                "not_applicable"
              ]
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter extract jobs created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter extract jobs created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "url",
            "in": "query",
            "description": "Filter extract jobs by the input URL used for extraction",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "include_data",
            "in": "query",
            "description": "Include the data in the response. If false, the response will only include the job information and not the data to minimize the response size.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of extract jobs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtractList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or extract config requires at least one option enabled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Extract job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Monthly extract jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/extract/{job_id}": {
      "get": {
        "tags": ["Extract"],
        "summary": "Retrieve the current state of an extraction job",
        "operationId": "getExtract",
        "description": "Retrieve the current state of an extraction job. Results are paginated with a default limit of 50 segment entities per request (maximum 100). Use limit and offset parameters to paginate through all segment entities.",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The unique identifier of the extraction job",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of segment entities to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100,
              "minimum": 1
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of segment entities to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response with job details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Extract"
                }
              }
            }
          },
          "404": {
            "description": "Job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Extract"],
        "summary": "Delete an extraction job",
        "operationId": "deleteExtract",
        "description": "Delete an extraction job",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The unique identifier of the extraction job",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful deletion",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "Unique identifier for the extract job"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files": {
      "post": {
        "tags": ["Files"],
        "summary": "Upload a video file that can be used with Cloudglue services",
        "operationId": "uploadFile",
        "description": "Upload a video file that can be used with Cloudglue services",
        "requestBody": {
          "description": "Upload a video file",
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/FileUpload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful file upload",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request, missing file, invalid metadata, or video duration exceeds limits",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "415": {
            "description": "Unsupported file type",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Resource limits exceeded (monthly upload limit, total duration, file size, or total files)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Files"],
        "summary": "List files that have been uploaded to Cloudglue",
        "operationId": "listFiles",
        "description": "List files that have been uploaded to Cloudglue",
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "description": "Filter files by processing status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "pending",
                "processing",
                "completed",
                "failed",
                "not_applicable"
              ]
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter files created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter files created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Limit the number of files to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of files to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the files by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["created_at", "filename"],
              "default": "created_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the files in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.\n\n**Supported Filter Types:**\n\n\u2022 **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')\n\u2022 **video_info** - Filter by video information properties\n  - `duration_seconds` - Video duration in seconds\n  - `has_audio` - Whether the video has audio (true/false)\n\n\u2022 **file** - Filter by file properties\n  - `filename` - File name (string)\n  - `uri` - File URI (string)\n  - `id` - File ID (UUID string)\n  - `created_at` - Creation timestamp (ISO 8601 string)\n  - `bytes` - File size in bytes (number)\n\n**Supported Operators:**\n\u2022 **Equal** - Exact match (requires valueText)\n\u2022 **NotEqual** - Not equal to value (requires valueText)\n\u2022 **LessThan** - Less than value (requires valueText)\n\u2022 **GreaterThan** - Greater than value (requires valueText)\n\u2022 **Like** - Case-insensitive pattern matching with wildcards (requires valueText)\n\u2022 **In** - Value is in array (requires valueTextArray)\n\u2022 **ContainsAny** - Array contains any of the values (requires valueTextArray)\n\u2022 **ContainsAll** - Array contains all of the values (requires valueTextArray)\n\n**Examples:**\n\n**Metadata filtering:**\n```json\n{\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]}\n```\n\n**Video info filtering:**\n```json\n{\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]}\n```\n\n**File property filtering:**\n```json\n{\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]}\n```\n```json\n{\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]}\n```\n```json\n{\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]}\n```\n\n**Combined filtering:**\n```json\n{\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]}\n```",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of files",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileList"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}": {
      "get": {
        "tags": ["Files"],
        "summary": "Retrieve details about a specific file",
        "operationId": "getFile",
        "description": "Retrieve details about a specific file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file to retrieve",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Files"],
        "summary": "Delete a file",
        "operationId": "deleteFile",
        "description": "Delete a file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file to delete",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful deletion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileDelete"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Files"],
        "summary": "Update a file",
        "operationId": "updateFile",
        "description": "Update a file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file to update",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "File update parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful file update",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/File"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or malformed file update parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/segmentations": {
      "post": {
        "tags": ["Files"],
        "summary": "Create a new segmentation for a file",
        "operationId": "createFileSegmentation",
        "description": "Create a new segmentation for a file using the specified segmentation configuration",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file to segment",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Segmentation configuration",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SegmentationConfig"
                  }
                ],
                "type": "object",
                "properties": {
                  "thumbnails_config": {
                    "$ref": "#/components/schemas/ThumbnailsConfig",
                    "description": "Configuration for segment thumbnails. Optional."
                  }
                },
                "description": "Segmentation configuration (root level) with optional thumbnails configuration."
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Segmentation created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Segmentation"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or file duration is less than window size",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Files"],
        "summary": "List segmentations for a file",
        "operationId": "listFileSegmentations",
        "description": "List all segmentations for a specific file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of segmentations to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of segmentations",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentationList"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/thumbnails": {
      "get": {
        "tags": ["Files", "Thumbnails"],
        "summary": "Get thumbnails for a file",
        "operationId": "getThumbnails",
        "description": "Get all thumbnails for a file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "is_default",
            "in": "query",
            "description": "Filter thumbnails by default status. If true, will only return the default thumbnail for the file",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "segmentation_id",
            "in": "query",
            "description": "Filter thumbnails by segmentation ID",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of thumbnails to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "Filter thumbnails by type",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ThumbnailType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of thumbnails",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThumbnailList"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/tags": {
      "get": {
        "tags": ["Files", "Tags"],
        "summary": "List tags for a file",
        "operationId": "listFileTags",
        "description": "List all tags for a specific file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of tags",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListVideoTagsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/segments": {
      "get": {
        "tags": ["Files", "File Segments"],
        "summary": "List file segments",
        "operationId": "listFileSegments",
        "description": "List all segments for a specific file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "start_time_after",
            "in": "query",
            "description": "Filter segments by start time",
            "required": false,
            "schema": {
              "type": "number",
              "minimum": 0
            }
          },
          {
            "name": "end_time_before",
            "in": "query",
            "description": "Filter segments by end time",
            "required": false,
            "schema": {
              "type": "number",
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of segments to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of segments",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileSegmentListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/segments/{segment_id}": {
      "get": {
        "tags": ["Files", "File Segments"],
        "summary": "Get a file segment",
        "operationId": "getFileSegment",
        "description": "Get a file segment",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segment_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segment",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File segment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileSegment"
                }
              }
            }
          },
          "404": {
            "description": "File segment not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Files", "File Segments"],
        "summary": "Update a file segment",
        "operationId": "updateFileSegment",
        "description": "Update a file segment",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segment_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segment",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "File segment update parameters",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "metadata": {
                    "type": "object",
                    "description": "The user defined metadata for the segment. Nullable"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "File segment updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileSegment"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or malformed file segment update parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File segment not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/segments/{segment_id}/tags": {
      "get": {
        "tags": ["Files", "File Segments", "Tags"],
        "summary": "List tags for a file segment",
        "operationId": "listFileSegmentTags",
        "description": "List all tags for a specific file segment",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segment_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segment",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of tags",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListVideoTagsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/segments/{segment_id}/describes": {
      "get": {
        "tags": ["Files", "File Segments", "Describe"],
        "summary": "List describes for a file segment",
        "operationId": "listFileSegmentDescribes",
        "description": "List all describe outputs for a specific file segment",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segment_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segment",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter by job status. Supports comma-separated values (e.g., 'completed,processing'). Defaults to 'completed'.",
            "required": false,
            "schema": {
              "type": "string",
              "default": "completed"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Output format for the describe data",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "include_data",
            "in": "query",
            "description": "Include the describe data in the response. If false, only job information is returned. Defaults to false.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of items to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of describes for the segment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentDescribeListResponse"
                }
              }
            }
          },
          "404": {
            "description": "File or segment not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/segments/{segment_id}/describes/{job_id}": {
      "get": {
        "tags": ["Files", "File Segments", "Describe"],
        "summary": "Get describe for a file segment",
        "operationId": "getFileSegmentDescribe",
        "description": "Get a specific describe output for a file segment by job ID",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segment_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segment",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The ID of the describe job",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Output format for the describe data",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Describe for the segment",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentDescribe"
                }
              }
            }
          },
          "404": {
            "description": "File, segment, or describe job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections": {
      "post": {
        "tags": ["Collections"],
        "summary": "Create a new collection to organize and process video files",
        "operationId": "createCollection",
        "description": "Create a new collection to organize and process video files. Collections are used to group files together and process them in a consistent way.",
        "requestBody": {
          "description": "Collection creation parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewCollection"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful collection creation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Collection"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or malformed YouTube URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "409": {
            "description": "Collection name already exists for this account",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Resource limits exceeded (total collections or files per collection)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Collections"],
        "summary": "List all collections",
        "operationId": "listCollections",
        "description": "List all collections",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of collections to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of collections to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the collections by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["name", "created_at"],
              "default": "created_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the collections in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          },
          {
            "name": "collection_type",
            "in": "query",
            "description": "Filter collections by type",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "media-descriptions",
                "entities",
                "rich-transcripts",
                "face-analysis"
              ]
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter collections created after this date (ISO 8601 format)",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter collections created before this date (ISO 8601 format)",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of collections",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionList"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}": {
      "get": {
        "tags": ["Collections"],
        "summary": "Retrieve details about a specific collection",
        "operationId": "getCollection",
        "description": "Retrieve details about a specific collection",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection to retrieve",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Collection details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Collection"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Collections"],
        "summary": "Delete a collection",
        "operationId": "deleteCollection",
        "description": "Delete a collection",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection to delete",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful deletion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionDelete"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Collections"],
        "summary": "Update a collection",
        "operationId": "updateCollection",
        "description": "Update a collection",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection to update",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Collection update parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CollectionUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful collection update",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Collection"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/videos": {
      "post": {
        "tags": ["Collections"],
        "summary": "[Deprecated] Add a video to a collection",
        "operationId": "addVideo",
        "description": "**DEPRECATED: Use POST /collections/\\{collection_id\\}/media instead.**\n\nAdd a video to a collection. This endpoint is deprecated - use the /media endpoint which supports both video and audio files.",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection to add the video file to",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "File association parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddCollectionFile"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful file addition",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionFile"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        },
        "deprecated": true
      },
      "get": {
        "tags": ["Collections"],
        "summary": "List all files in a collection",
        "operationId": "listVideos",
        "description": "List all files in a collection",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of files to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of files to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter by processing status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "pending",
                "processing",
                "completed",
                "failed",
                "not_applicable"
              ]
            }
          },
          {
            "name": "added_before",
            "in": "query",
            "description": "Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "added_after",
            "in": "query",
            "description": "Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the files by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["added_at", "filename"],
              "default": "added_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the files in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "JSON string containing filter criteria to constrain file search results. This is the JSON string version of the SearchFilter object used in the search API.\n\n**Supported Filter Types:**\n\n\u2022 **metadata** - Filter by file metadata using JSON path expressions (e.g., 'metadata.speaker', 'metadata.category.subcategory')\n\u2022 **video_info** - Filter by video information properties\n  - `duration_seconds` - Video duration in seconds\n  - `has_audio` - Whether the video has audio (true/false)\n\n\u2022 **file** - Filter by file properties\n  - `filename` - File name (string)\n  - `uri` - File URI (string)\n  - `id` - File ID (UUID string)\n  - `created_at` - Creation timestamp (ISO 8601 string)\n  - `bytes` - File size in bytes (number)\n\n**Supported Operators:**\n\u2022 **Equal** - Exact match (requires valueText)\n\u2022 **NotEqual** - Not equal to value (requires valueText)\n\u2022 **LessThan** - Less than value (requires valueText)\n\u2022 **GreaterThan** - Greater than value (requires valueText)\n\u2022 **Like** - Case-insensitive pattern matching with wildcards (requires valueText)\n\u2022 **In** - Value is in array (requires valueTextArray)\n\u2022 **ContainsAny** - Array contains any of the values (requires valueTextArray)\n\u2022 **ContainsAll** - Array contains all of the values (requires valueTextArray)\n\n**Examples:**\n\n**Metadata filtering:**\n```json\n{\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Like\",\"valueText\":\"YO%\"}]}\n```\n\n**Video info filtering:**\n```json\n{\"video_info\":[{\"path\":\"duration_seconds\",\"operator\":\"GreaterThan\",\"valueText\":\"60\"}]}\n```\n\n**File property filtering:**\n```json\n{\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]}\n```\n```json\n{\"file\":[{\"path\":\"bytes\",\"operator\":\"GreaterThan\",\"valueText\":\"1048576\"}]}\n```\n```json\n{\"file\":[{\"path\":\"created_at\",\"operator\":\"GreaterThan\",\"valueText\":\"2024-01-01T00:00:00Z\"}]}\n```\n\n**Combined filtering:**\n```json\n{\"metadata\":[{\"path\":\"speaker\",\"operator\":\"Equal\",\"valueText\":\"John\"}],\"video_info\":[{\"path\":\"has_audio\",\"operator\":\"Equal\",\"valueText\":\"true\"}],\"file\":[{\"path\":\"filename\",\"operator\":\"Like\",\"valueText\":\"%.mp4\"}]}\n```",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of files in the collection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionFileList"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/videos/{file_id}": {
      "get": {
        "tags": ["Collections"],
        "summary": "Retrieve information about a specific video file in a collection",
        "operationId": "getVideo",
        "description": "Retrieve information about a specific video file in a collection",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File details within the collection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionFile"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Collections"],
        "summary": "Remove a video file from a collection",
        "operationId": "deleteVideo",
        "description": "Remove a video file from a collection",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file to remove",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful removal",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionFileDelete"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/videos/{file_id}/entities": {
      "get": {
        "tags": ["Collections"],
        "summary": "Retrieve extracted entities for a specific file in a collection",
        "operationId": "getEntities",
        "description": "Retrieve extracted entities for a specific file in a collection. Results are paginated with a default limit of 50 segment entities per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'entities'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of segment entities to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100,
              "minimum": 1
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of segment entities to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File entities",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileEntities"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'entities'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/videos/{file_id}/rich-transcripts": {
      "get": {
        "tags": ["Collections"],
        "summary": "Retrieve rich transcription data for a specific file in a collection",
        "operationId": "getTranscripts",
        "description": "Retrieve rich transcription data for a specific file in a collection. This API is only available when the a collection is created with collection_type 'rich-transcripts'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "start_time_seconds",
            "in": "query",
            "description": "Start time in seconds to filter out results by",
            "required": false,
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "end_time_seconds",
            "in": "query",
            "description": "End time in seconds to filter out results by",
            "required": false,
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "modalities",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ModalitiesSchema"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Rich transcription data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RichTranscript"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'rich-transcripts'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/youtube": {
      "post": {
        "tags": ["Collections"],
        "summary": "Add a YouTube video to a collection",
        "operationId": "addYouTubeVideo",
        "description": "Add a YouTube video to a collection by URL",
        "deprecated": true,
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection to add the YouTube video to",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "YouTube video URL parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddYouTubeCollectionFile"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful video addition",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionFile"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or YouTube URL",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/entities": {
      "get": {
        "tags": ["Collections"],
        "summary": "List all extracted entities for files in a collection",
        "operationId": "listCollectionEntities",
        "description": "List all extracted entities for files in a collection. This API is only available when a collection is created with collection_type 'entities'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of files to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of files to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the files by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["added_at", "filename"],
              "default": "added_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the files in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          },
          {
            "name": "added_before",
            "in": "query",
            "description": "Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "added_after",
            "in": "query",
            "description": "Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of file entities in the collection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionEntitiesList"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'entities'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/rich-transcripts": {
      "get": {
        "tags": ["Collections"],
        "summary": "List all rich transcription data for files in a collection",
        "operationId": "listCollectionRichTranscripts",
        "description": "List all rich transcription data for files in a collection. This API is only available when a collection is created with collection_type 'rich-transcripts'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of files to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of files to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the files by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["added_at", "filename"],
              "default": "added_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the files in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          },
          {
            "name": "added_before",
            "in": "query",
            "description": "Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "added_after",
            "in": "query",
            "description": "Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "modalities",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ModalitiesSchema"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of rich transcription data in the collection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionRichTranscriptsList"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'rich-transcripts'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/media-descriptions": {
      "get": {
        "tags": ["Collections"],
        "summary": "List all media description data for files in a collection",
        "operationId": "listCollectionMediaDescriptions",
        "description": "List all media description data for files in a collection. This API is only available when a collection is created with collection_type 'media-descriptions'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of files to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of files to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the files by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["added_at", "filename"],
              "default": "added_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the files in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          },
          {
            "name": "added_before",
            "in": "query",
            "description": "Filter files added before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "added_after",
            "in": "query",
            "description": "Filter files added after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "modalities",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ModalitiesSchema"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of media description data in the collection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionMediaDescriptionsList"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'media-descriptions'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/videos/{file_id}/media-descriptions": {
      "get": {
        "tags": ["Collections"],
        "summary": "Retrieve media description data for a specific file in a collection",
        "operationId": "getMediaDescriptions",
        "description": "Retrieve media description data for a specific file in a collection. This API is only available when the collection is created with collection_type 'media-descriptions'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "start_time_seconds",
            "in": "query",
            "description": "Start time in seconds to filter out results by",
            "required": false,
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "end_time_seconds",
            "in": "query",
            "description": "End time in seconds to filter out results by",
            "required": false,
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "modalities",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ModalitiesSchema"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Media description data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaDescription"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'media-descriptions'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/chat/completions": {
      "post": {
        "tags": ["Chat"],
        "summary": "Generate a model response to a conversation that can include references to video content",
        "operationId": "createCompletion",
        "description": "Generate a model response to a conversation that can include references to video content",
        "requestBody": {
          "description": "Chat completion parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatCompletionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatCompletionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collections not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Chat completion limits reached (monthly or daily)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Chat"],
        "summary": "List all chat completions",
        "operationId": "listChatCompletions",
        "description": "List all chat completions with optional filtering",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of chat completions to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of chat completions to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter chat completions created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter chat completions created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of chat completions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatCompletionList"
                }
              }
            }
          }
        }
      }
    },
    "/chat/completions/{id}": {
      "get": {
        "tags": ["Chat"],
        "summary": "Retrieve a chat completion",
        "operationId": "getChatCompletion",
        "description": "Retrieve a chat completion",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the chat completion",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatCompletionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Chat completion not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/transcribe": {
      "post": {
        "tags": ["Transcribe"],
        "summary": "Create a new transcription job",
        "operationId": "createTranscribe",
        "description": "Creates a new transcription job for video content.\n\nNote: For most use cases, you should use the `/describe` endpoint instead. This API will be deprecated in the future and only supports speech level understanding.",
        "requestBody": {
          "description": "Transcription job parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewTranscribe"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transcribe"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or missing required url/file_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Chat completion limits reached (monthly or daily)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "509": {
            "description": "Monthly transcription jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Transcribe"],
        "summary": "List all transcription jobs",
        "operationId": "listTranscribes",
        "description": "List all transcription jobs with optional filtering",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of transcription jobs to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of transcription jobs to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter transcription jobs by status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "pending",
                "processing",
                "completed",
                "failed",
                "not_applicable"
              ]
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter transcription jobs created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter transcription jobs created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "url",
            "in": "query",
            "description": "Filter transcription jobs by the input URL used for transcription",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of transcription jobs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscribeList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/transcribe/{job_id}": {
      "get": {
        "tags": ["Transcribe"],
        "summary": "Retrieve the current state of a transcription job",
        "operationId": "getTranscribe",
        "description": "Retrieve the current state of a transcription job",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The unique identifier of the transcription job",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response with job details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transcribe"
                }
              }
            }
          },
          "404": {
            "description": "Job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/describe": {
      "post": {
        "tags": ["Describe"],
        "summary": "Create a new media description job",
        "operationId": "createDescribe",
        "description": "Get a comprehensive multimodal description of a video",
        "requestBody": {
          "description": "Media description job parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewDescribe"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Describe"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or missing required url/file_id",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Chat completion limits reached (monthly or daily)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "509": {
            "description": "Monthly description jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Describe"],
        "summary": "List all media description jobs",
        "operationId": "listDescribes",
        "description": "List all media description jobs with optional filtering",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of description jobs to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of description jobs to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter description jobs by status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "pending",
                "processing",
                "completed",
                "failed",
                "not_applicable"
              ]
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter description jobs created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter description jobs created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "url",
            "in": "query",
            "description": "Filter description jobs by the input URL used for description",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "include_data",
            "in": "query",
            "description": "Include the data in the response. If false, the response will only include the job information and not the data to minimize the response size.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "modalities",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ModalitiesSchema"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of description jobs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/describe/{job_id}": {
      "get": {
        "tags": ["Describe"],
        "summary": "Retrieve the current state of a media description job",
        "operationId": "getDescribe",
        "description": "Retrieve the current state of a media description job",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The unique identifier of the description job",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Format for the response",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "start_time_seconds",
            "in": "query",
            "description": "Start time in seconds to filter out results by",
            "required": false,
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "end_time_seconds",
            "in": "query",
            "description": "End time in seconds to filter out results by",
            "required": false,
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "modalities",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ModalitiesSchema"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response with job details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Describe"
                }
              }
            }
          },
          "404": {
            "description": "Job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Describe"],
        "summary": "Delete a media description job",
        "operationId": "deleteDescribe",
        "description": "Delete a media description job",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The unique identifier of the description job",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "Unique identifier for the describe job"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/webhooks": {
      "get": {
        "tags": ["Webhooks"],
        "summary": "List all webhooks",
        "operationId": "listWebhooks",
        "description": "List all webhooks",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of webhooks to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of webhooks to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the webhooks by a specific field",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["created_at"],
              "default": "created_at"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Sort the webhooks in ascending or descending order",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["asc", "desc"],
              "default": "desc"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of webhooks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookList"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Webhooks"],
        "summary": "Create a webhook",
        "operationId": "createWebhook",
        "description": "Create a webhook",
        "requestBody": {
          "description": "Webhook creation parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Webhook created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/webhooks/{webhook_id}": {
      "get": {
        "tags": ["Webhooks"],
        "summary": "Get a webhook by ID",
        "operationId": "getWebhookById",
        "description": "Get a webhook by ID",
        "parameters": [
          {
            "name": "webhook_id",
            "in": "path",
            "required": true,
            "description": "The ID of the webhook to get",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A webhook",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Webhooks"],
        "summary": "Delete a webhook",
        "operationId": "deleteWebhook",
        "description": "Delete a webhook",
        "parameters": [
          {
            "name": "webhook_id",
            "in": "path",
            "required": true,
            "description": "The ID of the webhook to delete",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful removal of webhook",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookDeleteResponse"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Webhooks"],
        "summary": "Update a webhook",
        "operationId": "updateWebhook",
        "description": "Update a webhook",
        "parameters": [
          {
            "name": "webhook_id",
            "in": "path",
            "required": true,
            "description": "The ID of the webhook to update",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Webhook update parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Webhook updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/search": {
      "post": {
        "tags": ["Search"],
        "summary": "Search across video files and segments to find relevant content",
        "operationId": "searchContent",
        "description": "Search for videos or video segments in collections to find relevant videos or moments/clips in a video",
        "requestBody": {
          "description": "Search parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful search results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Search"],
        "summary": "Get a list of search responses",
        "operationId": "getSearch",
        "description": "Get a list of search responses. Order by `created_at` in descending order by default.",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of search responses to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100,
              "minimum": 1
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of search responses to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter search responses created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter search responses created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A search",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponseList"
                }
              }
            }
          },
          "404": {
            "description": "Search not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/search/{search_id}": {
      "get": {
        "tags": ["Search"],
        "summary": "Get a search response by ID",
        "operationId": "getSearchById",
        "description": "Get a search response by search_id. ",
        "parameters": [
          {
            "name": "search_id",
            "in": "path",
            "required": true,
            "description": "The ID of the search response to get",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A search response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResponse"
                }
              }
            }
          },
          "404": {
            "description": "Search response not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/responses": {
      "post": {
        "tags": ["Response"],
        "summary": "Create a response",
        "operationId": "createResponse",
        "description": "Create a new response using the Response API. This endpoint provides an OpenAI Responses-compatible interface for chat completions with video collections.\n\nThe response can be processed synchronously (default) or asynchronously using the `background` parameter.",
        "requestBody": {
          "description": "Response creation parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateResponseRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Response"],
        "summary": "List responses",
        "operationId": "listResponses",
        "description": "List all responses with pagination and filtering options.",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of responses to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100,
              "minimum": 1
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of responses to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter by response status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["in_progress", "completed", "failed", "cancelled"]
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter responses created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter responses created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of responses",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseList"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/responses/{id}": {
      "get": {
        "tags": ["Response"],
        "summary": "Get a response by ID",
        "operationId": "getResponse",
        "description": "Retrieve a specific response by its ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the response to retrieve",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "404": {
            "description": "Response not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Response"],
        "summary": "Delete a response",
        "operationId": "deleteResponse",
        "description": "Delete a response by ID. This operation is idempotent - deleting a non-existent response returns success.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the response to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteResponseResult"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/responses/{id}/cancel": {
      "post": {
        "tags": ["Response"],
        "summary": "Cancel a response",
        "operationId": "cancelResponse",
        "description": "Cancel a background response that is in progress. If the response is already completed, failed, or cancelled, this returns the response as-is.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the response to cancel",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response cancelled or current status returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "404": {
            "description": "Response not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/videos/{file_id}/face-detections": {
      "get": {
        "tags": ["Collections"],
        "summary": "Retrieve face detections for a specific file in a collection",
        "operationId": "getFaceDetections",
        "description": "Retrieve face detections for a specific file in a collection. Results are paginated with a default limit of 50 faces per request (maximum 100). Use limit and offset parameters to paginate through all results. This API is only available when the collection is created with collection_type 'face-analysis'",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of faces to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100,
              "minimum": 1
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of faces to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "File face detections",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileFaceDetections"
                }
              }
            }
          },
          "400": {
            "description": "Collection type is not 'face-analysis'",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection, file, or face detection job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/segmentations/{segmentation_id}": {
      "get": {
        "tags": ["Segmentations"],
        "summary": "Get a specific segmentation",
        "operationId": "getSegmentation",
        "description": "Retrieve details about a specific segmentation including its segments",
        "parameters": [
          {
            "name": "segmentation_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segmentation to retrieve",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of segments to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 10
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the segments list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Segmentation details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Segmentation"
                }
              }
            }
          },
          "404": {
            "description": "Segmentation not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Segmentations"],
        "summary": "Delete a segmentation",
        "operationId": "deleteSegmentation",
        "description": "Delete a specific segmentation",
        "parameters": [
          {
            "name": "segmentation_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segmentation to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Segmentation deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the deleted segmentation"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Segmentation not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/files/{file_id}/frames": {
      "post": {
        "tags": ["Files"],
        "summary": "Create a new frame extraction for a file",
        "operationId": "createFileFrameExtraction",
        "description": "Create a new frame extraction for a file using the specified frame extraction configuration. This is an async operation that returns immediately with a 'pending' status. Results are cached, so identical requests will return the same frame extraction.",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file to extract frames from",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Frame extraction configuration",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FrameExtractionConfig"
                  }
                ],
                "type": "object",
                "properties": {
                  "thumbnails_config": {
                    "$ref": "#/components/schemas/FrameExtractionThumbnailsConfig",
                    "description": "Configuration for frame thumbnails. Optional."
                  }
                },
                "description": "Frame extraction configuration (root level) with optional thumbnails configuration."
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Frame extraction created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FrameExtraction"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request or file duration is less than specified time range",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Files"],
        "summary": "List frame extractions for a file",
        "operationId": "listFileFrameExtractions",
        "description": "List all frame extractions for a specific file",
        "parameters": [
          {
            "name": "file_id",
            "in": "path",
            "required": true,
            "description": "The ID of the file",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of frame extractions to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of frame extractions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FrameExtractionList"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/frames/{frame_extraction_id}": {
      "get": {
        "tags": ["Frames"],
        "summary": "Get a specific frame extraction",
        "operationId": "getFrameExtraction",
        "description": "Retrieve details about a specific frame extraction including its frames",
        "parameters": [
          {
            "name": "frame_extraction_id",
            "in": "path",
            "required": true,
            "description": "The ID of the frame extraction to retrieve",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of frames to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the frames list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Frame extraction details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FrameExtraction"
                }
              }
            }
          },
          "404": {
            "description": "Frame extraction not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Frames"],
        "summary": "Delete a frame extraction",
        "operationId": "deleteFrameExtraction",
        "description": "Delete a specific frame extraction",
        "parameters": [
          {
            "name": "frame_extraction_id",
            "in": "path",
            "required": true,
            "description": "The ID of the frame extraction to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Frame extraction deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the deleted frame extraction"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Frame extraction not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/segments": {
      "post": {
        "tags": ["Segments"],
        "summary": "Create a new segmentation job",
        "operationId": "createSegments",
        "description": "Create intelligent segments for video or audio files based on shot detection or narrative analysis.\n\n**Audio File Support:**\n\n- Audio files support **narrative** criteria only (shot detection is not available for audio).\n- Audio files automatically use the 'balanced' strategy.\n\n**Note: YouTube URLs and audio files are supported for narrative-based segmentation only.** Shot-based segmentation requires direct video file access. Use Cloudglue Files, HTTP URLs, or files from data connectors for shot-based segmentation.\n\n**Narrative Segmentation Strategies:**\n\n- **comprehensive** (default for non-YouTube/non-audio files): Uses a VLM to deeply analyze logical segments of video. Only available for video files (not YouTube or audio).\n- **balanced** (default for YouTube videos and audio files): Balanced analysis approach using multiple modalities. Supports YouTube URLs and audio files.\n\n**YouTube URLs and Audio Files**: Automatically use the 'balanced' strategy. The strategy field is ignored, and other strategies will be rejected with an error.\n\n**Chapter Count Parameters:**\n\n- **number_of_chapters**: Target number of chapters. If only this is provided, min_chapters and max_chapters are calculated automatically.\n- **min_chapters**: Minimum number of chapters. If provided with number_of_chapters and max, validates min is less than or equal to number_of_chapters which is less than or equal to max.\n- **max_chapters**: Maximum number of chapters. If provided with number_of_chapters and min, validates min is less than or equal to number_of_chapters which is less than or equal to max.\n- If none are provided, chapter counts are calculated automatically based on file duration.",
        "requestBody": {
          "description": "Segmentation job parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewSegments"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Segments"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request, missing required parameters, unsupported URL type (e.g., YouTube URLs with shot-based segmentation), or unsupported strategy for YouTube URLs (YouTube URLs only support 'balanced' strategy)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Monthly segments jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Segments"],
        "summary": "List all segmentation jobs",
        "operationId": "listSegments",
        "description": "List all segmentation jobs with optional filtering",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of segmentation jobs to return",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "maximum": 100
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of segmentation jobs to skip",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter segmentation jobs by status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["pending", "processing", "completed", "failed"]
            }
          },
          {
            "name": "criteria",
            "in": "query",
            "description": "Filter segmentation jobs by criteria type",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["shot", "narrative"]
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter segmentation jobs created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter segmentation jobs created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "url",
            "in": "query",
            "description": "Filter segmentation jobs by the input URL used for segmentation",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of segmentation jobs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SegmentsList"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/segments/{job_id}": {
      "get": {
        "tags": ["Segments"],
        "summary": "Retrieve the current state of a segmentation job",
        "operationId": "getSegments",
        "description": "Retrieve the current state of a segmentation job",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The unique identifier of the segmentation job",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response with job details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Segments"
                }
              }
            }
          },
          "404": {
            "description": "Job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Segments"],
        "summary": "Delete a segments job",
        "operationId": "deleteSegments",
        "description": "Delete a specific segments job",
        "parameters": [
          {
            "name": "job_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segments job to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Segments job deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the deleted segments job"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Segments job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/segmentations/{segmentation_id}/thumbnails": {
      "get": {
        "tags": ["Segmentations", "Thumbnails"],
        "summary": "Get thumbnails for a segmentation",
        "operationId": "getSegmentationThumbnails",
        "description": "Get all thumbnails for a segmentation",
        "parameters": [
          {
            "name": "segmentation_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segmentation to retrieve thumbnails for",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segment_ids",
            "in": "query",
            "description": "Filter thumbnails by segment IDs. If provided, will only return thumbnails for the specified segments. Comma separated list of segment IDs.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of thumbnails to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "Filter thumbnails by type",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/ThumbnailType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Segmentation thumbnails",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ThumbnailList"
                }
              }
            }
          },
          "404": {
            "description": "Segmentation not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/segmentations/{segmentation_id}/describes": {
      "get": {
        "tags": ["Segmentations", "Describe"],
        "summary": "List describe jobs for a segmentation",
        "operationId": "listSegmentationDescribes",
        "description": "List all describe jobs that referenced the specified segmentation. Returns describe job records associated with the segmentation.",
        "parameters": [
          {
            "name": "segmentation_id",
            "in": "path",
            "required": true,
            "description": "The ID of the segmentation job",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "include_data",
            "in": "query",
            "description": "Include the describe data in the response. If false, only job information is returned. Defaults to false.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "response_format",
            "in": "query",
            "description": "Output format for the describe data",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["json", "markdown"],
              "default": "json"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of items to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of describe outputs for the segmentation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeList"
                }
              }
            }
          },
          "404": {
            "description": "Segmentation not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/face-match": {
      "post": {
        "tags": ["Face Match"],
        "summary": "Find matching face in video",
        "operationId": "createFaceMatch",
        "description": "Search for a source face in a target video using facial recognition",
        "requestBody": {
          "description": "Face match request parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FaceMatchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Face match job created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceMatch"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters or source image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Target video file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Monthly face match jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Face Match"],
        "summary": "List face match jobs",
        "operationId": "listFaceMatch",
        "description": "List all face match jobs",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Number of face match jobs to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the face match jobs list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter face match jobs created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter face match jobs created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter by status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["pending", "processing", "completed", "failed"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Face match jobs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceMatchListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/face-match/{face_match_id}": {
      "get": {
        "tags": ["Face Match"],
        "summary": "Get face match results",
        "operationId": "getFaceMatch",
        "description": "Retrieve face match results including detected faces and similarity scores",
        "parameters": [
          {
            "name": "face_match_id",
            "in": "path",
            "required": true,
            "description": "The ID of the face match to retrieve",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of face matches to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the face matches list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Face match results retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceMatch"
                }
              }
            }
          },
          "404": {
            "description": "Face match job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Face Match"],
        "summary": "Delete face match analysis",
        "operationId": "deleteFaceMatch",
        "description": "Delete a specific face match analysis",
        "parameters": [
          {
            "name": "face_match_id",
            "in": "path",
            "required": true,
            "description": "The ID of the face match to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Face match deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "face_match_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the deleted face match"
                    },
                    "object": {
                      "type": "string",
                      "enum": ["face_match"],
                      "description": "Object type, always 'face_match'"
                    }
                  },
                  "required": ["face_match_id", "object"]
                }
              }
            }
          },
          "404": {
            "description": "Face match job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/face-detect": {
      "post": {
        "tags": ["Face Detection"],
        "summary": "Detect faces in video",
        "operationId": "createFaceDetection",
        "description": "Analyze video to detect all faces",
        "requestBody": {
          "description": "Face detection request parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FaceDetectionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Face detection job created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceDetection"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters or configuration",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Target video file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "429": {
            "description": "Monthly face detection jobs limit reached",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Face Detection"],
        "summary": "List face detection jobs",
        "operationId": "listFaceDetection",
        "description": "List all face detection jobs",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Number of face detection jobs to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the face detection jobs list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter face detection jobs created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter face detection jobs created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Filter by status",
            "required": false,
            "schema": {
              "type": "string",
              "enum": ["pending", "processing", "completed", "failed"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Face detection jobs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceDetectionListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/face-detect/{face_detection_id}": {
      "get": {
        "tags": ["Face Detection"],
        "summary": "Get face detection results",
        "operationId": "getFaceDetection",
        "description": "Retrieve face detection results including all detected faces",
        "parameters": [
          {
            "name": "face_detection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the face detection to retrieve",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of detected faces to return",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the detected faces list",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Face detection results retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FaceDetection"
                }
              }
            }
          },
          "404": {
            "description": "Face detection job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Face Detection"],
        "summary": "Delete face detection analysis",
        "operationId": "deleteFaceDetection",
        "description": "Delete a specific face detection analysis",
        "parameters": [
          {
            "name": "face_detection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the face detection to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Face detection deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the deleted face detection"
                    }
                  },
                  "required": ["id"]
                }
              }
            }
          },
          "404": {
            "description": "Face detection job not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/share": {
      "post": {
        "tags": ["Share"],
        "summary": "Create a publicly available shareable asset",
        "operationId": "createShareableAsset",
        "description": "Create a publicly available shareable asset",
        "requestBody": {
          "description": "Shareable asset creation request parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateShareableAssetRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Shareable asset created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareableAsset"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request parameters or configuration",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "File or file segment not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "409": {
            "description": "Shareable asset already exists",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": ["Share"],
        "summary": "List shareable assets",
        "operationId": "listShareableAssets",
        "description": "List shareable assets",
        "parameters": [
          {
            "name": "file_id",
            "in": "query",
            "description": "The ID of the file to list shareable assets for",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "file_segment_id",
            "in": "query",
            "description": "The ID of the file segment to list shareable assets for",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Number of shareable assets to return",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 100,
              "default": 50
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Offset from the start of the shareable assets list",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0
            }
          },
          {
            "name": "created_before",
            "in": "query",
            "description": "Filter shareable assets created before a specific date (YYYY-MM-DD format), in UTC timezone",
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "created_after",
            "in": "query",
            "description": "Filter shareable assets created after a specific date (YYYY-MM-DD format), in UTC timezone",
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Shareable assets listed successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareableAssetListResponse"
                }
              }
            }
          }
        }
      }
    },
    "/share/{id}": {
      "get": {
        "tags": ["Share"],
        "summary": "Get a shareable asset",
        "operationId": "getShareableAsset",
        "description": "Get a shareable asset",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the shareable asset to retrieve",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Shareable asset retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareableAsset"
                }
              }
            }
          },
          "404": {
            "description": "Shareable asset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Share"],
        "summary": "Delete a shareable asset",
        "operationId": "deleteShareableAsset",
        "description": "Delete a shareable asset",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the shareable asset to delete",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Shareable asset deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the deleted shareable asset"
                    },
                    "object": {
                      "type": "string",
                      "enum": ["share"],
                      "description": "Object type, always 'share'"
                    }
                  },
                  "required": ["id", "object"]
                }
              }
            }
          },
          "404": {
            "description": "Shareable asset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Share"],
        "summary": "Update a shareable asset",
        "operationId": "updateShareableAsset",
        "description": "Update a shareable asset",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "description": "The ID of the shareable asset to update",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Shareable asset update request parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateShareableAssetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Shareable asset updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareableAsset"
                }
              }
            }
          },
          "404": {
            "description": "Shareable asset not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    },
    "/collections/{collection_id}/media": {
      "post": {
        "tags": ["Collections"],
        "summary": "Add a media file to a collection",
        "operationId": "addMedia",
        "description": "Add a video or audio file to a collection. This is the recommended endpoint for adding media files to collections.\n\n**Media Type Handling:**\n\n- **Video files**: Processed with full visual analysis (scene description, text extraction, etc.)\n- **Audio files**: Visual features automatically disabled; only speech and audio analysis available\n\n**Audio File Restrictions:**\n\n- Audio files cannot be added to face-analysis collections\n- Shot-detector segmentation is not available for audio files",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "description": "The ID of the collection to add the media file to",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "File association parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddCollectionFile"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful file addition",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionFile"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request (e.g., audio files with shot-detector segmentation, audio in face-analysis collections)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "404": {
            "description": "Collection or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          },
          "500": {
            "description": "An unexpected error occurred on the server",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "CreateResponseRequest": {
        "type": "object",
        "required": ["model", "input", "knowledge_base"],
        "properties": {
          "model": {
            "type": "string",
            "minLength": 1,
            "example": "nimbus-001",
            "description": "The model to use for generating the response.\n\n- `nimbus-001`: Fast general question answering model. Default temperature: 0.7.\n- `nimbus-002-preview`: Light reasoning model capable of multi-step reasoning, cross-video synthesis, and structured entity data. Supports `entity_collections` in the knowledge base. Default temperature: 1."
          },
          "input": {
            "oneOf": [
              {
                "type": "string",
                "description": "A simple string input (treated as a user message)"
              },
              {
                "type": "array",
                "description": "An array of message objects",
                "items": {
                  "$ref": "#/components/schemas/ResponseInputMessage"
                }
              }
            ],
            "description": "The input for the response. Can be a simple string or an array of messages."
          },
          "instructions": {
            "type": "string",
            "description": "System instructions to guide the model's behavior (maps to developer/system message)"
          },
          "temperature": {
            "type": "number",
            "minimum": 0,
            "maximum": 2,
            "description": "Sampling temperature for the model. Defaults to 0.7 for nimbus-001 and 1 for nimbus-002-preview."
          },
          "knowledge_base": {
            "$ref": "#/components/schemas/ResponseKnowledgeBase"
          },
          "include": {
            "type": "array",
            "items": {
              "type": "string",
              "enum": ["cloudglue_citations.media_descriptions"]
            },
            "description": "Additional data to include in the response annotations"
          },
          "background": {
            "type": "boolean",
            "default": false,
            "description": "Set to true to process the response in the background. When true, the response is returned immediately with status 'in_progress'."
          },
          "stream": {
            "type": "boolean",
            "default": false,
            "description": "Stream response via SSE. Mutually exclusive with background."
          }
        }
      },
      "ResponseInputMessage": {
        "type": "object",
        "required": ["type", "role", "content"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["message"],
            "description": "The type of the message"
          },
          "role": {
            "type": "string",
            "enum": ["developer", "user", "assistant"],
            "description": "The role of the message sender. 'developer' maps to system instructions."
          },
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponseInputContent"
            },
            "description": "The content of the message"
          }
        }
      },
      "ResponseInputContent": {
        "type": "object",
        "required": ["type", "text"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["input_text"],
            "description": "The type of content"
          },
          "text": {
            "type": "string",
            "description": "The text content"
          }
        }
      },
      "ResponseKnowledgeBase": {
        "type": "object",
        "description": "Configuration for the video collections to search against for response context",
        "required": ["collections"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["general_question_answering", "entity_backed_knowledge"],
            "default": "general_question_answering",
            "description": "The type of knowledge base interaction pattern.\n\n- `general_question_answering` (default): Search-and-answer over media collections.\n- `entity_backed_knowledge`: Enables structured entity lookups alongside video content. Requires `entity_backed_knowledge_config` and `nimbus-002-preview` model."
          },
          "collections": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "minItems": 1,
            "description": "Collection IDs to search for relevant context"
          },
          "filter": {
            "description": "Optional filter to narrow down the search within collections.\n\nSupports filtering by `metadata`, `video_info`, and `file` properties. Each filter is an array of criteria with `path`, `operator`, and `valueText` or `valueTextArray`.\n\nSupported operators: `Equal`, `NotEqual`, `LessThan`, `GreaterThan`, `In`, `ContainsAny`, `ContainsAll`.\n\nExamples:\n- Filter by file ID: `{\"file\": [{\"path\": \"id\", \"operator\": \"Equal\", \"valueText\": \"file-uuid\"}]}`\n- Filter by metadata: `{\"metadata\": [{\"path\": \"speaker\", \"operator\": \"Equal\", \"valueText\": \"Amy\"}]}`\n- Filter by duration: `{\"video_info\": [{\"path\": \"duration_seconds\", \"operator\": \"GreaterThan\", \"valueText\": \"60\"}]}`",
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchFilter"
              }
            ]
          },
          "entity_backed_knowledge_config": {
            "$ref": "#/components/schemas/EntityBackedKnowledgeConfig"
          }
        }
      },
      "EntityBackedKnowledgeConfig": {
        "type": "object",
        "description": "Configuration for entity-backed knowledge. Required when `type` is `entity_backed_knowledge`. Contains entity collections with pre-extracted structured data and optional domain context.",
        "required": ["entity_collections"],
        "properties": {
          "entity_collections": {
            "type": "array",
            "minItems": 1,
            "description": "List of entity collections that provide pre-extracted structured data. Only supported with `nimbus-002-preview` model.\n\nEntity collections contain structured entities extracted from the same videos in the main collection (e.g., action items, speakers, topics). The model can use these for fast, structured lookups instead of searching raw content.",
            "items": {
              "$ref": "#/components/schemas/EntityCollectionConfig"
            }
          },
          "description": {
            "type": "string",
            "maxLength": 2000,
            "description": "General context about the videos in this collection. Helps the model understand the domain.\n\nExamples:\n- \"Sales call recordings with enterprise prospects from Q4 2024\"\n- \"Product demo videos for the Acme Analytics platform\"\n- \"Weekly team standup recordings from the engineering org\""
          }
        }
      },
      "EntityCollectionConfig": {
        "type": "object",
        "description": "Configuration for an entity collection used with `nimbus-002-preview`. Contains structured, pre-extracted data from the same videos as the main media collection.",
        "required": ["collection_id"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name for the entity collection (e.g., `action_items`, `speakers_and_roles`). Used by the model to decide which collection to query. Falls back to the collection's stored name if omitted."
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of what this entity collection contains. Helps the model decide when to use this collection. Falls back to the collection's stored description if omitted."
          },
          "collection_id": {
            "type": "string",
            "format": "uuid",
            "description": "UUID of the entity collection. Must be an existing collection of type `entities`."
          }
        }
      },
      "Response": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the response"
          },
          "object": {
            "type": "string",
            "enum": ["response"],
            "description": "Object type identifier"
          },
          "status": {
            "type": "string",
            "enum": ["in_progress", "completed", "failed", "cancelled"],
            "description": "Current status of the response"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp of when the response was created"
          },
          "model": {
            "type": "string",
            "description": "The model used for the response"
          },
          "instructions": {
            "type": "string",
            "nullable": true,
            "description": "The system instructions used"
          },
          "output": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/ResponseOutputMessage"
            },
            "description": "The generated output messages"
          },
          "usage": {
            "$ref": "#/components/schemas/ResponseUsage",
            "nullable": true
          },
          "error": {
            "$ref": "#/components/schemas/ResponseError",
            "nullable": true
          }
        }
      },
      "ResponseOutputMessage": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["message"],
            "description": "The type of output"
          },
          "role": {
            "type": "string",
            "enum": ["assistant"],
            "description": "The role (always assistant for outputs)"
          },
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponseOutputContent"
            },
            "description": "The content items in the output"
          }
        }
      },
      "ResponseOutputContent": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["output_text"],
            "description": "The type of content"
          },
          "text": {
            "type": "string",
            "description": "The generated text"
          },
          "annotations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponseAnnotation"
            },
            "description": "Citations and references in the output"
          }
        }
      },
      "ResponseAnnotation": {
        "type": "object",
        "required": ["type", "collection_id", "file_id", "start_time"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["cloudglue_citation"],
            "description": "The type of annotation"
          },
          "collection_id": {
            "type": "string",
            "format": "uuid",
            "description": "The collection containing the cited content"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The file containing the cited content"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The specific segment cited. Present when a matching segment is found."
          },
          "start_time": {
            "type": "number",
            "description": "Start time of the cited content in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time of the cited segment in seconds. Present when a matching segment is found."
          },
          "context": {
            "type": "string",
            "description": "The text context of the citation"
          },
          "relevant_sources": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Relevant source descriptions (included when 'cloudglue_citations.media_descriptions' is requested)"
          },
          "visual_scene_description": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Visual descriptions (included when 'cloudglue_citations.media_descriptions' is requested)"
          },
          "scene_text": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "On-screen text (included when 'cloudglue_citations.media_descriptions' is requested)"
          },
          "speech": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Speech transcripts (included when 'cloudglue_citations.media_descriptions' is requested)"
          },
          "audio_description": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Audio descriptions (included when 'cloudglue_citations.media_descriptions' is requested)"
          }
        }
      },
      "ResponseUsage": {
        "type": "object",
        "description": "Token usage statistics for the response",
        "properties": {
          "input_tokens": {
            "type": "integer",
            "description": "Number of input tokens used"
          },
          "output_tokens": {
            "type": "integer",
            "description": "Number of output tokens generated"
          },
          "total_tokens": {
            "type": "integer",
            "description": "Total tokens used"
          }
        }
      },
      "ResponseError": {
        "type": "object",
        "description": "Error details when the response status is 'failed'",
        "nullable": true,
        "properties": {
          "message": {
            "type": "string",
            "description": "Error message"
          },
          "type": {
            "type": "string",
            "description": "Error type"
          },
          "code": {
            "type": "string",
            "description": "Error code"
          }
        }
      },
      "ResponseList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type identifier"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResponseListItem"
            },
            "description": "List of responses"
          },
          "total": {
            "type": "integer",
            "description": "Total number of responses matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of responses returned"
          },
          "offset": {
            "type": "integer",
            "description": "Number of responses skipped"
          }
        }
      },
      "ResponseListItem": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the response"
          },
          "object": {
            "type": "string",
            "enum": ["response"],
            "description": "Object type identifier"
          },
          "status": {
            "type": "string",
            "enum": ["in_progress", "completed", "failed", "cancelled"],
            "description": "Current status of the response"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp of when the response was created"
          },
          "model": {
            "type": "string",
            "description": "The model used for the response"
          },
          "instructions": {
            "type": "string",
            "nullable": true,
            "description": "The system instructions used"
          },
          "usage": {
            "$ref": "#/components/schemas/ResponseUsage",
            "nullable": true
          }
        }
      },
      "DeleteResponseResult": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the deleted response"
          },
          "object": {
            "type": "string",
            "enum": ["response"],
            "description": "Object type identifier"
          },
          "deleted": {
            "type": "boolean",
            "enum": [true],
            "description": "Indicates successful deletion"
          }
        }
      },
      "DescribeOutputPart": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "description": "Text content"
          },
          "start_time": {
            "type": "number",
            "description": "Start time in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time in seconds"
          }
        }
      },
      "SpeechOutputPart": {
        "type": "object",
        "properties": {
          "speaker": {
            "type": "string",
            "description": "Identified speaker"
          },
          "text": {
            "type": "string",
            "description": "Transcribed speech text"
          },
          "start_time": {
            "type": "number",
            "description": "Start time of speech in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time of speech in seconds"
          }
        }
      },
      "DescribeOutput": {
        "type": "object",
        "properties": {
          "visual_scene_description": {
            "type": "array",
            "description": "Array of visual descriptions",
            "items": {
              "$ref": "#/components/schemas/DescribeOutputPart"
            }
          },
          "scene_text": {
            "type": "array",
            "description": "Array of scene text extractions",
            "items": {
              "$ref": "#/components/schemas/DescribeOutputPart"
            }
          },
          "speech": {
            "type": "array",
            "description": "Array of speech transcriptions",
            "items": {
              "$ref": "#/components/schemas/SpeechOutputPart"
            }
          },
          "audio_description": {
            "type": "array",
            "description": "Array of audio descriptions",
            "items": {
              "$ref": "#/components/schemas/DescribeOutputPart"
            }
          }
        }
      },
      "Extract": {
        "required": ["job_id", "status"],
        "type": "object",
        "properties": {
          "job_id": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ]
          },
          "url": {
            "type": "string",
            "description": "The URL of the processed video"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "extract_config": {
            "type": "object",
            "description": "Configuration for automatic entity extraction from videos",
            "properties": {
              "prompt": {
                "type": "string",
                "description": "A natural language prompt describing the data to extract. Required if no schema is provided."
              },
              "schema": {
                "type": "object",
                "description": "A more rigid structure if you already know the JSON layout you want. Required if no prompt is provided."
              },
              "enable_video_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the video level. Mutually exclusive with enable_segment_level_entities - only one can be true.",
                "default": false
              },
              "enable_segment_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the segment level. Mutually exclusive with enable_video_level_entities - only one can be true.",
                "default": true
              },
              "enable_transcript_mode": {
                "type": "boolean",
                "description": "When enabled, extract entities from transcript only (similar to YouTube path). Useful for speech-heavy content.",
                "default": false
              }
            }
          },
          "segmentation_id": {
            "type": "string",
            "description": "The ID of the segmentation job used for this extraction"
          },
          "data": {
            "description": "The structured data extracted from the video based on prompt or schema. Only present when status is 'completed'.",
            "type": "object",
            "properties": {
              "entities": {
                "type": "object",
                "description": "Entities extracted from the video level"
              },
              "segment_entities": {
                "type": "array",
                "description": "Array of video entities extracted from individual time segments",
                "items": {
                  "type": "object",
                  "properties": {
                    "start_time": {
                      "type": "number",
                      "description": "Start time of the segment in seconds"
                    },
                    "end_time": {
                      "type": "number",
                      "description": "End time of the segment in seconds"
                    },
                    "entities": {
                      "type": "object",
                      "description": "Entities extracted from the segment"
                    }
                  }
                }
              }
            }
          },
          "total": {
            "type": "integer",
            "description": "Total number of segment entities available. Only present when status is 'completed'."
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of segment entities returned per request. Only present when status is 'completed'."
          },
          "offset": {
            "type": "integer",
            "description": "Number of segment entities skipped. Only present when status is 'completed'."
          },
          "error": {
            "type": "string",
            "description": "Error message if status is 'failed'"
          }
        }
      },
      "ExtractList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Extract"
            },
            "description": "Array of extract job objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of extract jobs matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "NewExtract": {
        "allOf": [
          {
            "required": ["url"],
            "type": "object",
            "properties": {
              "url": {
                "description": "Input video URL. Supports URIs of files uploaded to Cloudglue Files endpoint, public YouTube video URLs, public HTTP URLs, and files which have been granted access to Cloudglue via data connectors.\n\nNote that YouTube videos are currently limited to speech level understanding only. For files via our Data connectors, see our documentation on data connectors for setup information.",
                "type": "string"
              },
              "prompt": {
                "description": "A natural language prompt describing the data you want to extract. Required if no schema is provided.",
                "type": "string"
              },
              "schema": {
                "description": "A more rigid structure if you already know the JSON layout you want. Required if no prompt is provided.",
                "type": "object"
              },
              "enable_video_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the video level. Mutually exclusive with enable_segment_level_entities - only one can be true.",
                "default": false
              },
              "enable_segment_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the segment level. Mutually exclusive with enable_video_level_entities - only one can be true.",
                "default": true
              },
              "enable_transcript_mode": {
                "type": "boolean",
                "description": "When enabled, extract entities from transcript only (similar to YouTube path). Useful for speech-heavy content.",
                "default": false
              },
              "thumbnails_config": {
                "$ref": "#/components/schemas/ThumbnailsConfig"
              }
            }
          },
          {
            "$ref": "#/components/schemas/FileSegmentationConfig"
          }
        ]
      },
      "File": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the file"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ],
            "description": "Processing status of the file"
          },
          "bytes": {
            "type": "integer",
            "nullable": true,
            "description": "Size of the file in bytes, null if not available"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the file was created"
          },
          "filename": {
            "type": "string",
            "description": "Original filename"
          },
          "uri": {
            "type": "string",
            "description": "Cloudglue URI for the file, to be used in other API calls"
          },
          "metadata": {
            "type": "object",
            "nullable": true,
            "description": "User-provided metadata about the file, null if none provided"
          },
          "media_type": {
            "type": "string",
            "enum": ["video", "audio"],
            "description": "Type of media file (video or audio)"
          },
          "media_info": {
            "type": "object",
            "properties": {
              "duration_seconds": {
                "type": "number",
                "nullable": true,
                "description": "Duration in seconds"
              },
              "width": {
                "type": "integer",
                "nullable": true,
                "description": "Video width in pixels (null for audio files)"
              },
              "height": {
                "type": "integer",
                "nullable": true,
                "description": "Video height in pixels (null for audio files)"
              },
              "sample_rate": {
                "type": "integer",
                "nullable": true,
                "description": "Audio sample rate in Hz"
              },
              "channels": {
                "type": "integer",
                "nullable": true,
                "description": "Number of audio channels"
              },
              "bitrate": {
                "type": "integer",
                "nullable": true,
                "description": "Audio bitrate in bps"
              },
              "format": {
                "type": "string",
                "nullable": true,
                "description": "File format"
              },
              "has_audio": {
                "type": "boolean",
                "nullable": true,
                "description": "Whether the file has audio"
              }
            },
            "description": "Unified media information for both video and audio files"
          },
          "video_info": {
            "type": "object",
            "properties": {
              "duration_seconds": {
                "type": "number",
                "nullable": true,
                "description": "Duration of the video in seconds, null if not available"
              },
              "height": {
                "type": "integer",
                "nullable": true,
                "description": "Height of the video in pixels, null if not available"
              },
              "width": {
                "type": "integer",
                "nullable": true,
                "description": "Width of the video in pixels, null if not available"
              },
              "format": {
                "type": "string",
                "nullable": true,
                "description": "Format of the video file, null if not available"
              },
              "has_audio": {
                "type": "boolean",
                "nullable": true,
                "description": "Whether the video has audio, null if not available"
              }
            },
            "description": "Information about the video content"
          },
          "thumbnail_url": {
            "type": "string",
            "description": "URL of the thumbnail for the file"
          },
          "source": {
            "type": "string",
            "enum": [
              "video",
              "youtube",
              "s3",
              "dropbox",
              "http",
              "upload",
              "google-drive",
              "zoom",
              "gong",
              "recall",
              "gcs"
            ],
            "description": "Source of the file"
          }
        },
        "required": ["id", "uri", "status"]
      },
      "FileUpload": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "format": "binary",
            "description": "The video file to be uploaded"
          },
          "metadata": {
            "type": "object",
            "description": "User-provided metadata about the file"
          },
          "enable_segment_thumbnails": {
            "type": "boolean",
            "description": "Whether to generate thumbnails for each segment",
            "default": false
          }
        },
        "required": ["file"]
      },
      "FileList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/File"
            },
            "description": "Array of file objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of files matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "FileDelete": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID of the deleted file"
          },
          "object": {
            "type": "string",
            "enum": ["file"],
            "description": "Object type, always 'file'"
          }
        },
        "required": ["id", "object"]
      },
      "FileUpdate": {
        "type": "object",
        "properties": {
          "metadata": {
            "type": "object",
            "description": "Optional user-provided metadata about the file"
          },
          "filename": {
            "type": "string",
            "description": "New filename for the file"
          }
        }
      },
      "Collection": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the collection"
          },
          "object": {
            "type": "string",
            "enum": ["collection"],
            "description": "Object type, always 'collection'"
          },
          "name": {
            "type": "string",
            "description": "Name of the collection"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the collection's purpose or contents, null if none provided"
          },
          "collection_type": {
            "type": "string",
            "enum": [
              "media-descriptions",
              "entities",
              "rich-transcripts",
              "face-analysis"
            ],
            "description": "Type of collection, determines how videos are processed and what data is extracted"
          },
          "extract_config": {
            "type": "object",
            "description": "Configuration for automatic entity extraction from videos. Required when collection_type is 'entities'.",
            "properties": {
              "prompt": {
                "type": "string",
                "description": "A natural language prompt describing the data to extract. Required if no schema is provided."
              },
              "schema": {
                "type": "object",
                "description": "A more rigid structure if you already know the JSON layout you want. Required if no prompt is provided."
              },
              "enable_video_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the video level. Mutually exclusive with enable_segment_level_entities - only one can be true.",
                "default": false
              },
              "enable_segment_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the segment level. Mutually exclusive with enable_video_level_entities - only one can be true.",
                "default": true
              },
              "enable_transcript_mode": {
                "type": "boolean",
                "description": "When enabled, extract entities from transcript only. Useful for speech-heavy content.",
                "default": false
              }
            }
          },
          "transcribe_config": {
            "type": "object",
            "description": "Configuration for rich transcription from videos. Used when collection_type is 'rich-transcripts'. If not provided, default values will be used.",
            "properties": {
              "enable_summary": {
                "type": "boolean",
                "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
                "default": true
              },
              "enable_speech": {
                "type": "boolean",
                "description": "Whether to generate speech transcript",
                "default": true
              },
              "enable_scene_text": {
                "type": "boolean",
                "description": "Whether to generate scene text extraction",
                "default": false
              },
              "enable_visual_scene_description": {
                "type": "boolean",
                "description": "Whether to generate visual scene description",
                "default": false
              },
              "enable_audio_description": {
                "type": "boolean",
                "description": "Whether to generate audio description",
                "default": false
              }
            }
          },
          "describe_config": {
            "type": "object",
            "description": "Configuration for comprehensive media description from videos. Used when collection_type is 'media-descriptions'. If not provided, default values will be used.",
            "properties": {
              "enable_summary": {
                "type": "boolean",
                "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
                "default": true
              },
              "enable_speech": {
                "type": "boolean",
                "description": "Whether to generate speech transcript",
                "default": true
              },
              "enable_scene_text": {
                "type": "boolean",
                "description": "Whether to generate scene text extraction",
                "default": true
              },
              "enable_visual_scene_description": {
                "type": "boolean",
                "description": "Whether to generate visual scene description",
                "default": true
              },
              "enable_audio_description": {
                "type": "boolean",
                "description": "Whether to generate audio description",
                "default": false
              }
            }
          },
          "default_segmentation_config": {
            "$ref": "#/components/schemas/SegmentationConfig",
            "description": "Default segmentation configuration used for files in this collection"
          },
          "default_thumbnails_config": {
            "$ref": "#/components/schemas/ThumbnailsConfig",
            "description": "Default thumbnails configuration used for files in this collection"
          },
          "face_detection_config": {
            "type": "object",
            "nullable": true,
            "description": "Configuration for face detection in videos. Only present when collection_type is 'face-analysis'.",
            "properties": {
              "frame_extraction_config": {
                "type": "object",
                "properties": {
                  "strategy": {
                    "type": "string",
                    "enum": ["uniform"],
                    "description": "Frame extraction strategy"
                  },
                  "uniform_config": {
                    "type": "object",
                    "properties": {
                      "frames_per_second": {
                        "type": "number",
                        "minimum": 0.1,
                        "maximum": 30,
                        "default": 1,
                        "description": "Number of frames to extract per second"
                      },
                      "max_width": {
                        "type": "number",
                        "minimum": 64,
                        "maximum": 4096,
                        "default": 1024,
                        "description": "Maximum width of frames in pixels (aspect ratio preserved)"
                      }
                    }
                  }
                },
                "required": ["strategy"]
              },
              "thumbnails_config": {
                "type": "object",
                "properties": {
                  "enable_frame_thumbnails": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to generate thumbnails for extracted frames"
                  }
                }
              }
            }
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the collection was created"
          },
          "file_count": {
            "type": "integer",
            "description": "Number of files in the collection"
          }
        },
        "required": [
          "id",
          "object",
          "name",
          "created_at",
          "file_count",
          "collection_type"
        ]
      },
      "CollectionUpdate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the collection"
          },
          "description": {
            "type": "string",
            "description": "Description of the collection"
          }
        }
      },
      "NewCollection": {
        "type": "object",
        "properties": {
          "collection_type": {
            "type": "string",
            "enum": [
              "media-descriptions",
              "entities",
              "rich-transcripts",
              "face-analysis"
            ],
            "description": "Type of collection, determines how videos are processed and what data is extracted.\n\n**Collection Types:**\n- **media-descriptions**: Generate comprehensive media descriptions with speech, visual, and text analysis (use `describe_config`)\n- **entities**: Extract structured data/entities from videos (requires `extract_config`)\n- **rich-transcripts**: Generate rich transcriptions with speech and visual descriptions (use `transcribe_config`). For backward compatibility only, new collections should use `media-descriptions` instead.\n- **face-analysis**: Detect and index faces in videos for face matching and search (use `face_detection_config`)\n\n\u26a0\ufe0f **Important**: Only provide the config that matches your collection_type. Other configs will be ignored."
          },
          "name": {
            "type": "string",
            "description": "Name of the collection (must be unique within an organization)"
          },
          "description": {
            "type": "string",
            "nullable": true,
            "description": "Description of the collection's purpose or contents, null if none provided"
          },
          "describe_config": {
            "type": "object",
            "description": "\ud83c\udfaf **Use ONLY when collection_type = 'media-descriptions'**\n\nConfiguration for comprehensive media description from videos. Optional - if not provided, default values will be used. This config will be ignored for other collection types.",
            "properties": {
              "enable_summary": {
                "type": "boolean",
                "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
                "default": true
              },
              "enable_speech": {
                "type": "boolean",
                "description": "Whether to generate speech transcript",
                "default": true
              },
              "enable_scene_text": {
                "type": "boolean",
                "description": "Whether to generate scene text extraction",
                "default": true
              },
              "enable_visual_scene_description": {
                "type": "boolean",
                "description": "Whether to generate visual scene description",
                "default": true
              },
              "enable_audio_description": {
                "type": "boolean",
                "description": "Whether to generate audio description",
                "default": false
              }
            }
          },
          "extract_config": {
            "type": "object",
            "description": "\ud83c\udfaf **Use ONLY when collection_type = 'entities'**\n\nConfiguration for automatic entity extraction from videos. Required for entities collections. This config will be ignored for other collection types.",
            "properties": {
              "prompt": {
                "type": "string",
                "description": "A natural language prompt describing the data to extract. Required if no schema is provided."
              },
              "schema": {
                "type": "object",
                "description": "A more rigid structure if you already know the JSON layout you want. Required if no prompt is provided."
              },
              "enable_video_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the video level. Mutually exclusive with enable_segment_level_entities - only one can be true.",
                "default": false
              },
              "enable_segment_level_entities": {
                "type": "boolean",
                "description": "Whether to extract entities at the segment level. Mutually exclusive with enable_video_level_entities - only one can be true.",
                "default": true
              },
              "enable_transcript_mode": {
                "type": "boolean",
                "description": "When enabled, extract entities from transcript only. Useful for speech-heavy content.",
                "default": false
              }
            }
          },
          "transcribe_config": {
            "type": "object",
            "description": "\ud83c\udfaf **Use ONLY when collection_type = 'rich-transcripts'**\n\nConfiguration for rich transcription from videos. Optional - if not provided, default values will be used. This config will be ignored for other collection types.",
            "properties": {
              "enable_summary": {
                "type": "boolean",
                "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
                "default": true
              },
              "enable_speech": {
                "type": "boolean",
                "description": "Whether to generate speech transcript",
                "default": true
              },
              "enable_scene_text": {
                "type": "boolean",
                "description": "Whether to generate scene text extraction",
                "default": false
              },
              "enable_visual_scene_description": {
                "type": "boolean",
                "description": "Whether to generate visual scene description",
                "default": false
              },
              "enable_audio_description": {
                "type": "boolean",
                "description": "Whether to generate audio description",
                "default": false
              }
            }
          },
          "default_segmentation_config": {
            "$ref": "#/components/schemas/DefaultSegmentationConfig",
            "description": "Default segmentation configuration to use for files added to this collection. If not provided, a default uniform segmentation will be used."
          },
          "default_thumbnails_config": {
            "$ref": "#/components/schemas/ThumbnailsConfig",
            "description": "Default thumbnails configuration to use for files added to this collection. If not provided, a default thumbnails configuration will be used."
          },
          "face_detection_config": {
            "type": "object",
            "description": "\ud83c\udfaf **Use ONLY when collection_type = 'face-analysis'**\n\nConfiguration for face detection in videos. Optional - if not provided, default values will be used. This config will be ignored for other collection types.",
            "properties": {
              "frame_extraction_config": {
                "type": "object",
                "properties": {
                  "strategy": {
                    "type": "string",
                    "enum": ["uniform"],
                    "description": "Frame extraction strategy"
                  },
                  "uniform_config": {
                    "type": "object",
                    "properties": {
                      "frames_per_second": {
                        "type": "number",
                        "minimum": 0.1,
                        "maximum": 30,
                        "default": 1,
                        "description": "Number of frames to extract per second"
                      },
                      "max_width": {
                        "type": "number",
                        "minimum": 64,
                        "maximum": 4096,
                        "default": 1024,
                        "description": "Maximum width of frames in pixels (aspect ratio preserved)"
                      }
                    }
                  }
                },
                "required": ["strategy"]
              },
              "thumbnails_config": {
                "type": "object",
                "properties": {
                  "enable_frame_thumbnails": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to generate thumbnails for extracted frames"
                  }
                }
              }
            }
          }
        },
        "required": ["collection_type", "name"]
      },
      "CollectionList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Collection"
            },
            "description": "Array of collection objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of collections matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "CollectionDelete": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID of the deleted collection"
          },
          "object": {
            "type": "string",
            "enum": ["collection"],
            "description": "Object type, always 'collection'"
          }
        },
        "required": ["id", "object"]
      },
      "AddCollectionFile": {
        "allOf": [
          {
            "type": "object",
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "file_id": {
                    "type": "string",
                    "description": "The ID of the file to add to the collection"
                  }
                },
                "required": ["file_id"]
              },
              {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "description": "The URL of the video to add to the collection. Supports URIs of files uploaded to Cloudglue Files endpoint, public YouTube video URLs, public HTTP URLs, and files which have been granted access to Cloudglue via data connectors.\n\nNote that YouTube videos are currently limited to speech level understanding only. For files via our Data connectors, see our documentation on data connectors for setup information."
                  }
                },
                "required": ["url"]
              }
            ]
          },
          {
            "$ref": "#/components/schemas/FileSegmentationConfig"
          },
          {
            "type": "object",
            "properties": {
              "thumbnails_config": {
                "$ref": "#/components/schemas/ThumbnailsConfig"
              }
            }
          }
        ]
      },
      "AddYouTubeCollectionFile": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "description": "The URL of the YouTube video to add to the collection.\n\nNote that YouTube videos are currently limited to speech and metadata level understanding, for fully fledge multimodal video understanding please upload a file instead to the Files API and use that object instead as input."
              },
              "metadata": {
                "type": "object",
                "description": "User-provided metadata about the YouTube video"
              }
            },
            "required": ["url"]
          },
          {
            "$ref": "#/components/schemas/FileSegmentationConfig"
          }
        ]
      },
      "CollectionFile": {
        "type": "object",
        "properties": {
          "collection_id": {
            "type": "string",
            "description": "ID of the collection"
          },
          "file_id": {
            "type": "string",
            "description": "ID of the file"
          },
          "object": {
            "type": "string",
            "enum": ["collection_file"],
            "description": "Object type, always 'collection_file'"
          },
          "added_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the file was added to the collection"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ],
            "description": "Overall processing status of the file in this collection"
          },
          "file": {
            "$ref": "#/components/schemas/File",
            "description": "The file object"
          },
          "segmentation": {
            "type": "object",
            "description": "Segmentation information for this file in the collection. Only present when the file has been segmented.",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the segmentation"
              },
              "status": {
                "type": "string",
                "enum": [
                  "pending",
                  "processing",
                  "completed",
                  "failed",
                  "not_applicable"
                ],
                "description": "Status of the segmentation job"
              },
              "file_id": {
                "type": "string",
                "format": "uuid",
                "description": "ID of the file that was segmented"
              },
              "segmentation_config": {
                "$ref": "#/components/schemas/SegmentationConfig",
                "description": "Configuration used for this segmentation"
              }
            },
            "required": ["id", "status", "file_id", "segmentation_config"]
          }
        },
        "required": ["collection_id", "file_id", "object", "added_at", "status"]
      },
      "CollectionFileList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CollectionFile"
            },
            "description": "Array of collection file objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of files matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "CollectionFileDelete": {
        "type": "object",
        "properties": {
          "collection_id": {
            "type": "string",
            "description": "ID of the collection"
          },
          "file_id": {
            "type": "string",
            "description": "ID of the file"
          },
          "object": {
            "type": "string",
            "enum": ["collection_file"],
            "description": "Object type, always 'collection_file'"
          }
        },
        "required": ["collection_id", "file_id", "object"]
      },
      "FileEntities": {
        "type": "object",
        "properties": {
          "collection_id": {
            "type": "string",
            "description": "ID of the collection"
          },
          "file_id": {
            "type": "string",
            "description": "ID of the file"
          },
          "entities": {
            "type": "object",
            "description": "Entities extracted from the file at the video level"
          },
          "segment_entities": {
            "type": "array",
            "description": "Array of video entities extracted from individual time segments",
            "items": {
              "type": "object",
              "properties": {
                "start_time": {
                  "type": "number",
                  "description": "Start time of the segment in seconds"
                },
                "end_time": {
                  "type": "number",
                  "description": "End time of the segment in seconds"
                },
                "entities": {
                  "type": "object",
                  "description": "Entities extracted from the segment"
                }
              }
            }
          },
          "total": {
            "type": "integer",
            "description": "Total number of segment entities available"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of entities returned per request"
          },
          "offset": {
            "type": "integer",
            "description": "Number of entities skipped"
          }
        },
        "required": [
          "collection_id",
          "file_id",
          "entities",
          "segment_entities",
          "total",
          "limit",
          "offset"
        ]
      },
      "FileFaceDetections": {
        "type": "object",
        "properties": {
          "collection_id": {
            "type": "string",
            "description": "ID of the collection"
          },
          "file_id": {
            "type": "string",
            "description": "ID of the file"
          },
          "faces": {
            "type": "array",
            "description": "Array of detected faces",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid",
                  "description": "Unique identifier for the detected face"
                },
                "face_bounding_box": {
                  "type": "object",
                  "properties": {
                    "height": {
                      "type": "number",
                      "minimum": 0,
                      "maximum": 1,
                      "description": "Height of the bounding box (normalized 0-1)"
                    },
                    "width": {
                      "type": "number",
                      "minimum": 0,
                      "maximum": 1,
                      "description": "Width of the bounding box (normalized 0-1)"
                    },
                    "top": {
                      "type": "number",
                      "minimum": 0,
                      "maximum": 1,
                      "description": "Top position of the bounding box (normalized 0-1)"
                    },
                    "left": {
                      "type": "number",
                      "minimum": 0,
                      "maximum": 1,
                      "description": "Left position of the bounding box (normalized 0-1)"
                    }
                  },
                  "required": ["height", "width", "top", "left"]
                },
                "frame_id": {
                  "type": "string",
                  "format": "uuid",
                  "description": "ID of the frame where the face was detected"
                },
                "timestamp": {
                  "type": "number",
                  "minimum": 0,
                  "description": "Timestamp of the frame in seconds"
                },
                "thumbnail_url": {
                  "type": "string",
                  "description": "URL of the frame thumbnail (if frame extraction enabled thumbnails)"
                }
              },
              "required": ["id", "face_bounding_box", "frame_id", "timestamp"]
            }
          },
          "total": {
            "type": "integer",
            "description": "Total number of faces detected"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of faces returned per request"
          },
          "offset": {
            "type": "integer",
            "description": "Number of faces skipped"
          }
        },
        "required": [
          "collection_id",
          "file_id",
          "faces",
          "total",
          "limit",
          "offset"
        ]
      },
      "Error": {
        "required": ["error"],
        "type": "object",
        "properties": {
          "error": {
            "type": "string"
          }
        }
      },
      "ChatCompletionRequest": {
        "type": "object",
        "properties": {
          "model": {
            "type": "string",
            "description": "Name of the video understanding model to use.",
            "enum": ["nimbus-001"]
          },
          "messages": {
            "type": "array",
            "description": "A list of messages comprising the conversation so far",
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            }
          },
          "collections": {
            "type": "array",
            "description": "List of collection IDs to use as context for the chat.\n\nNote that 'nimbus-001' only supports collections with collection_type 'media-descriptions' or 'rich-transcripts'",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "maxItems": 1
          },
          "filter": {
            "type": "object",
            "description": "Filter criteria to constrain search results used in chat",
            "properties": {
              "metadata": {
                "type": "array",
                "description": "Filter by file metadata using JSON path expressions",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "JSON path on metadata object (e.g. 'my_custom_field', 'category.subcategory')"
                    },
                    "operator": {
                      "type": "string",
                      "enum": [
                        "NotEqual",
                        "Equal",
                        "LessThan",
                        "GreaterThan",
                        "In",
                        "ContainsAny",
                        "ContainsAll"
                      ],
                      "description": "Comparison operator to apply"
                    },
                    "valueText": {
                      "type": "string",
                      "description": "Text value for scalar comparison (used with NotEqual, Equal, LessThan, GreaterThan, In)"
                    },
                    "valueTextArray": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "Array of values for array comparisons (used with ContainsAny, ContainsAll)"
                    }
                  },
                  "required": ["path", "operator"]
                }
              },
              "video_info": {
                "type": "array",
                "description": "Filter by video information using JSON path expressions",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "JSON path on video_info object (e.g. 'has_audio', 'duration_seconds')"
                    },
                    "operator": {
                      "type": "string",
                      "enum": [
                        "NotEqual",
                        "Equal",
                        "LessThan",
                        "GreaterThan",
                        "In",
                        "ContainsAny",
                        "ContainsAll"
                      ],
                      "description": "Comparison operator to apply"
                    },
                    "valueText": {
                      "type": "string",
                      "description": "Text value for scalar comparison (used with NotEqual, Equal, LessThan, GreaterThan, In)"
                    },
                    "valueTextArray": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "Array of values for array comparisons (used with ContainsAny, ContainsAll)"
                    }
                  },
                  "required": ["path", "operator"]
                }
              },
              "file": {
                "type": "array",
                "description": "Filter by file properties using JSON path expressions",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "JSON path on file object (e.g. 'uri', 'id', 'filename', 'created_at', 'bytes')"
                    },
                    "operator": {
                      "type": "string",
                      "enum": [
                        "NotEqual",
                        "Equal",
                        "LessThan",
                        "GreaterThan",
                        "In",
                        "ContainsAny",
                        "ContainsAll"
                      ],
                      "description": "Comparison operator to apply"
                    },
                    "valueText": {
                      "type": "string",
                      "description": "Text value for scalar comparison (used with NotEqual, Equal, LessThan, GreaterThan, In)"
                    },
                    "valueTextArray": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "Array of values for array comparisons (used with ContainsAny, ContainsAll)"
                    }
                  },
                  "required": ["path", "operator"]
                }
              }
            }
          },
          "temperature": {
            "type": "number",
            "description": "Sampling temperature to use, between 0 and 2",
            "minimum": 0,
            "maximum": 2,
            "default": 0.7
          }
        },
        "required": ["model", "messages", "collections"]
      },
      "ChatMessage": {
        "type": "object",
        "properties": {
          "role": {
            "type": "string",
            "description": "The role of the message author",
            "enum": ["system", "user", "assistant"]
          },
          "content": {
            "type": "string",
            "description": "The content of the message"
          },
          "name": {
            "type": "string",
            "description": "The name of the author of this message"
          }
        },
        "required": ["role", "content"]
      },
      "ChatCompletionResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for this chat completion"
          },
          "object": {
            "type": "string",
            "description": "Object type, always \"chat.completion\""
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the chat completion was created"
          },
          "model": {
            "type": "string",
            "description": "The model used for the chat completion"
          },
          "choices": {
            "type": "array",
            "description": "The generated responses",
            "items": {
              "type": "object",
              "properties": {
                "index": {
                  "type": "integer",
                  "description": "The index of this choice"
                },
                "message": {
                  "$ref": "#/components/schemas/ChatMessage",
                  "description": "The chat message generated by the model"
                },
                "citations": {
                  "type": "array",
                  "description": "Citations to specific video segments that informed the response",
                  "items": {
                    "allOf": [
                      {
                        "type": "object",
                        "properties": {
                          "collection_id": {
                            "type": "string",
                            "description": "ID of the collection containing the cited video"
                          },
                          "file_id": {
                            "type": "string",
                            "description": "ID of the file being cited"
                          },
                          "segment_id": {
                            "type": "string",
                            "description": "ID of the segment being cited"
                          },
                          "start_time": {
                            "oneOf": [
                              {
                                "type": "string",
                                "description": "Start time of the cited segment in seconds"
                              },
                              {
                                "type": "number",
                                "description": "Start time of the cited segment in seconds"
                              }
                            ],
                            "description": "Start time of the cited segment in seconds"
                          },
                          "end_time": {
                            "oneOf": [
                              {
                                "type": "string",
                                "description": "End time of the cited segment in seconds"
                              },
                              {
                                "type": "number",
                                "description": "End time of the cited segment in seconds"
                              }
                            ],
                            "description": "End time of the cited segment in seconds"
                          },
                          "text": {
                            "type": "string",
                            "description": "(Deprecated) Relevant text from the segment; use context and relevant_sources instead"
                          },
                          "context": {
                            "type": "string",
                            "description": "Short explanation of the relevance of the segment to the query provided as context"
                          },
                          "relevant_sources": {
                            "type": "array",
                            "description": "List of source modalities in segment that are relevant for this citation",
                            "items": {
                              "type": "object",
                              "properties": {
                                "text": {
                                  "type": "string",
                                  "description": "Source modality, one of visual_scene_description, scene_text, speech"
                                }
                              }
                            }
                          }
                        }
                      },
                      {
                        "$ref": "#/components/schemas/DescribeOutput"
                      }
                    ]
                  }
                }
              }
            }
          },
          "payload": {
            "$ref": "#/components/schemas/ChatCompletionPayload"
          },
          "usage": {
            "type": "object",
            "description": "Usage statistics for the completion request",
            "properties": {
              "prompt_tokens": {
                "type": "integer",
                "description": "Number of tokens in the prompt"
              },
              "completion_tokens": {
                "type": "integer",
                "description": "Number of tokens in the generated completion"
              },
              "total_tokens": {
                "type": "integer",
                "description": "Total number of tokens used in the request"
              }
            }
          }
        }
      },
      "Transcribe": {
        "required": ["job_id", "status"],
        "type": "object",
        "properties": {
          "job_id": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ]
          },
          "url": {
            "type": "string",
            "description": "The URL of the processed video"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "transcribe_config": {
            "type": "object",
            "description": "Configuration for rich transcription from videos",
            "properties": {
              "enable_summary": {
                "type": "boolean",
                "description": "Whether the user requested to generate video-level and segment-level (moment-level) summaries and titles"
              },
              "enable_speech": {
                "type": "boolean",
                "description": "Whether the user requested to generate speech transcript"
              },
              "enable_visual_scene_description": {
                "type": "boolean",
                "description": "Whether the user requested to generate visual scene description"
              },
              "enable_scene_text": {
                "type": "boolean",
                "description": "Whether the user requested to generate scene text"
              }
            }
          },
          "data": {
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "content": {
                    "type": "string",
                    "description": "Content string returned based on formatting, e.g. set to markdown text when response_format=markdown is requested"
                  },
                  "title": {
                    "type": "string",
                    "description": "Generated title of the video; for YouTube videos, this is the title of the video as it appears on YouTube"
                  },
                  "summary": {
                    "type": "string",
                    "description": "Generated video level summary; for YouTube videos, this is the summary of the video as it appears on YouTube"
                  },
                  "segment_summary": {
                    "type": "array",
                    "description": "Array of summary information for each segment of the video. Only available when enable_summary is set to true in the transcribe configuration.",
                    "items": {
                      "type": "object",
                      "properties": {
                        "title": {
                          "type": "string",
                          "description": "Generated segment-level title"
                        },
                        "summary": {
                          "type": "string",
                          "description": "Generated segment-level summary"
                        },
                        "start_time": {
                          "type": "number",
                          "description": "Start time of segment in seconds"
                        },
                        "end_time": {
                          "type": "number",
                          "description": "End time of segment in seconds"
                        }
                      }
                    }
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DescribeOutput"
              }
            ]
          },
          "error": {
            "type": "string",
            "description": "Error message if status is 'failed'"
          }
        }
      },
      "NewTranscribe": {
        "allOf": [
          {
            "type": "object",
            "required": ["url"],
            "properties": {
              "url": {
                "description": "Input video URL. Supports URIs of files uploaded to Cloudglue Files endpoint, public YouTube video URLs, public HTTP URLs, and files which have been granted access to Cloudglue via data connectors.\n\nNote that YouTube videos are currently limited to speech level understanding only. For files via our Data connectors, see our documentation on data connectors for setup information.",
                "type": "string"
              },
              "enable_summary": {
                "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
                "type": "boolean",
                "default": true
              },
              "enable_speech": {
                "description": "Whether to generate speech transcript",
                "type": "boolean",
                "default": true
              },
              "enable_visual_scene_description": {
                "description": "Whether to generate visual scene description",
                "type": "boolean",
                "default": false
              },
              "enable_scene_text": {
                "description": "Whether to generate scene text extraction",
                "type": "boolean",
                "default": false
              },
              "enable_audio_description": {
                "description": "Whether to generate audio description",
                "type": "boolean",
                "default": false
              },
              "thumbnails_config": {
                "$ref": "#/components/schemas/ThumbnailsConfig"
              }
            }
          },
          {
            "$ref": "#/components/schemas/FileSegmentationConfig"
          }
        ]
      },
      "TranscribeList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Transcribe"
            },
            "description": "Array of transcription job objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of transcription jobs matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          }
        },
        "required": ["object", "data", "total", "limit"]
      },
      "DescribeConfig": {
        "type": "object",
        "description": "Configuration for media description from videos",
        "properties": {
          "enable_summary": {
            "type": "boolean",
            "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
            "default": true
          },
          "enable_speech": {
            "type": "boolean",
            "description": "Whether to generate speech transcript",
            "default": true
          },
          "enable_visual_scene_description": {
            "type": "boolean",
            "description": "Whether to generate visual scene description",
            "default": true
          },
          "enable_scene_text": {
            "type": "boolean",
            "description": "Whether to generate scene text extraction",
            "default": true
          },
          "enable_audio_description": {
            "type": "boolean",
            "description": "Whether to generate audio description",
            "default": false
          }
        }
      },
      "SegmentDescribeOutputEntry": {
        "type": "object",
        "description": "A single describe output entry with timestamp",
        "properties": {
          "text": {
            "type": "string",
            "description": "The text content"
          },
          "start_time": {
            "type": "number",
            "description": "Start time in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time in seconds"
          }
        },
        "required": ["text", "start_time", "end_time"]
      },
      "SegmentDescribeSpeechEntry": {
        "type": "object",
        "description": "A speech entry with optional speaker information",
        "properties": {
          "text": {
            "type": "string",
            "description": "The speech text"
          },
          "start_time": {
            "type": "number",
            "description": "Start time in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time in seconds"
          },
          "speaker": {
            "type": "string",
            "description": "Speaker identifier"
          }
        },
        "required": ["text", "start_time", "end_time"]
      },
      "SegmentDescribeJsonData": {
        "type": "object",
        "description": "JSON format describe output data",
        "properties": {
          "visual_scene_description": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentDescribeOutputEntry"
            },
            "description": "Visual scene descriptions with timestamps"
          },
          "speech": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentDescribeSpeechEntry"
            },
            "description": "Speech transcript with timestamps and speaker info"
          },
          "scene_text": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentDescribeOutputEntry"
            },
            "description": "On-screen text detected with timestamps"
          },
          "audio_description": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentDescribeOutputEntry"
            },
            "description": "Audio descriptions with timestamps"
          },
          "title": {
            "type": "string",
            "description": "Generated title for the segment"
          },
          "summary": {
            "type": "string",
            "description": "Generated summary for the segment"
          },
          "start_time": {
            "type": "number",
            "description": "Start time of the segment in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time of the segment in seconds"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segment"
          }
        }
      },
      "SegmentDescribeMarkdownData": {
        "type": "object",
        "description": "Markdown format describe output data",
        "properties": {
          "content": {
            "type": "string",
            "description": "Markdown formatted content containing the describe output"
          }
        },
        "required": ["content"]
      },
      "SegmentDescribe": {
        "type": "object",
        "description": "Describe output for a specific video segment",
        "properties": {
          "job_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the describe job"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the video segment"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ],
            "description": "Status of the describe job"
          },
          "describe_config": {
            "$ref": "#/components/schemas/DescribeConfig"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "completed_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job completed"
          },
          "start_time": {
            "type": "number",
            "description": "Start time of the segment in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time of the segment in seconds"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file"
          },
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segmentation job"
          },
          "data": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/SegmentDescribeJsonData"
              },
              {
                "$ref": "#/components/schemas/SegmentDescribeMarkdownData"
              }
            ],
            "description": "The describe output data. When response_format=json, contains visual_scene_description, speech, scene_text, and audio_description arrays. When response_format=markdown, contains a content string."
          },
          "object": {
            "type": "string",
            "enum": ["segment_describe"],
            "description": "Object type"
          }
        },
        "required": [
          "job_id",
          "segment_id",
          "status",
          "describe_config",
          "created_at",
          "start_time",
          "end_time",
          "file_id",
          "object"
        ]
      },
      "SegmentDescribeListResponse": {
        "type": "object",
        "description": "List of describe outputs for a video segment",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentDescribe"
            },
            "description": "Array of segment describe objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of describe jobs for this segment"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "NewDescribe": {
        "allOf": [
          {
            "type": "object",
            "required": ["url"],
            "properties": {
              "url": {
                "description": "Input video URL. Supports URIs of files uploaded to Cloudglue Files endpoint, public YouTube video URLs, public HTTP URLs, and files which have been granted access to Cloudglue via data connectors.\n\nNote that YouTube videos are currently limited to speech level understanding only. For files via our Data connectors, see our documentation on data connectors for setup information.",
                "type": "string"
              },
              "enable_summary": {
                "description": "Whether to generate video-level and segment-level (moment-level) summaries and titles",
                "type": "boolean",
                "default": true
              },
              "enable_speech": {
                "description": "Whether to generate speech transcript",
                "type": "boolean",
                "default": true
              },
              "enable_visual_scene_description": {
                "description": "Whether to generate visual scene description",
                "type": "boolean",
                "default": true
              },
              "enable_scene_text": {
                "description": "Whether to generate scene text extraction",
                "type": "boolean",
                "default": true
              },
              "enable_audio_description": {
                "description": "Whether to generate audio description",
                "type": "boolean",
                "default": false
              },
              "thumbnails_config": {
                "$ref": "#/components/schemas/ThumbnailsConfig"
              }
            }
          },
          {
            "$ref": "#/components/schemas/FileSegmentationConfig"
          }
        ]
      },
      "Describe": {
        "required": ["job_id", "status"],
        "type": "object",
        "properties": {
          "job_id": {
            "type": "string"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ]
          },
          "url": {
            "type": "string",
            "description": "The URL of the processed video"
          },
          "duration_seconds": {
            "type": "number",
            "description": "Duration of the video in seconds"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "describe_config": {
            "type": "object",
            "description": "Configuration for media description from videos",
            "properties": {
              "enable_summary": {
                "type": "boolean",
                "description": "Whether the user requested to generate video-level and segment-level (moment-level) summaries and titles"
              },
              "enable_speech": {
                "type": "boolean",
                "description": "Whether the user requested to generate speech transcript"
              },
              "enable_visual_scene_description": {
                "type": "boolean",
                "description": "Whether the user requested to generate visual scene description"
              },
              "enable_scene_text": {
                "type": "boolean",
                "description": "Whether the user requested to generate scene text"
              },
              "enable_audio_description": {
                "type": "boolean",
                "description": "Whether the user requested to generate audio description"
              }
            }
          },
          "data": {
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "content": {
                    "type": "string",
                    "description": "Content string returned based on formatting, e.g. set to markdown text when response_format=markdown is requested"
                  },
                  "title": {
                    "type": "string",
                    "description": "Generated title of the video; for YouTube videos, this is the title of the video as it appears on YouTube"
                  },
                  "summary": {
                    "type": "string",
                    "description": "Generated video level summary; for YouTube videos, this is the summary of the video as it appears on YouTube"
                  },
                  "segment_summary": {
                    "type": "array",
                    "description": "Array of summary information for each segment of the video. Only available when enable_summary is set to true in the describe configuration.",
                    "items": {
                      "type": "object",
                      "properties": {
                        "title": {
                          "type": "string",
                          "description": "Generated segment-level title"
                        },
                        "summary": {
                          "type": "string",
                          "description": "Generated segment-level summary"
                        },
                        "start_time": {
                          "type": "number",
                          "description": "Start time of segment in seconds"
                        },
                        "end_time": {
                          "type": "number",
                          "description": "End time of segment in seconds"
                        }
                      }
                    }
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DescribeOutput"
              }
            ]
          },
          "error": {
            "type": "string",
            "description": "Error message if status is 'failed'"
          },
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segmentation job if the describe was run with a segmentation"
          }
        }
      },
      "DescribeList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Describe"
            },
            "description": "Array of describe job objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of describe jobs matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "MediaDescription": {
        "allOf": [
          {
            "type": "object",
            "required": ["collection_id", "file_id"],
            "properties": {
              "collection_id": {
                "type": "string",
                "description": "Unique identifier for the collection"
              },
              "file_id": {
                "type": "string",
                "description": "Unique identifier for the file"
              },
              "content": {
                "type": "string",
                "description": "Content string returned based on formatting, e.g. set to markdown text when response_format=markdown is requested"
              },
              "title": {
                "type": "string",
                "description": "Generated title of the video"
              },
              "summary": {
                "type": "string",
                "description": "Generated video level summary"
              },
              "duration_seconds": {
                "type": "number",
                "description": "Duration of the video in seconds"
              },
              "segment_summary": {
                "type": "array",
                "description": "Array of summary information for each segment of the video",
                "items": {
                  "type": "object",
                  "properties": {
                    "title": {
                      "type": "string",
                      "description": "Generated segment-level title"
                    },
                    "summary": {
                      "type": "string",
                      "description": "Generated segment-level summary"
                    },
                    "start_time": {
                      "type": "number",
                      "description": "Start time of segment in seconds"
                    },
                    "end_time": {
                      "type": "number",
                      "description": "End time of segment in seconds"
                    }
                  }
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/DescribeOutput"
          }
        ]
      },
      "RichTranscript": {
        "allOf": [
          {
            "type": "object",
            "required": ["collection_id", "file_id"],
            "properties": {
              "collection_id": {
                "type": "string",
                "description": "The ID of the collection"
              },
              "file_id": {
                "type": "string",
                "description": "The ID of the file"
              },
              "content": {
                "type": "string",
                "description": "Content string returned based on formatting, e.g. set to markdown text when response_format=markdown is requested"
              },
              "title": {
                "type": "string",
                "description": "Generated title of the video"
              },
              "summary": {
                "type": "string",
                "description": "Generated video level summary"
              },
              "duration_seconds": {
                "type": "number",
                "description": "Duration of the video in seconds"
              },
              "segment_summary": {
                "type": "array",
                "description": "Array of summary information for each segment of the video. Only available when enable_summary is set to true in the transcribe configuration.",
                "items": {
                  "type": "object",
                  "properties": {
                    "title": {
                      "type": "string",
                      "description": "Generated segment-level title"
                    },
                    "summary": {
                      "type": "string",
                      "description": "Generated segment-level summary"
                    },
                    "start_time": {
                      "type": "number",
                      "description": "Start time of segment in seconds"
                    },
                    "end_time": {
                      "type": "number",
                      "description": "End time of segment in seconds"
                    }
                  }
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/DescribeOutput"
          }
        ]
      },
      "Webhook": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the webhook"
          },
          "object": {
            "type": "string",
            "enum": ["webhook"],
            "description": "Object type, always 'webhook'"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the webhook was created"
          },
          "webhook_secret": {
            "type": "string",
            "description": "Secret used to verify the webhook request"
          },
          "endpoint": {
            "type": "string",
            "description": "URL of the webhook endpoint"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the webhook is active"
          },
          "description": {
            "type": "string",
            "description": "Description of the webhook"
          },
          "subscribed_events": {
            "type": "array",
            "description": "Events that the webhook is subscribed to",
            "items": {
              "$ref": "#/components/schemas/WebhookEvents"
            }
          }
        },
        "required": [
          "id",
          "object",
          "created_at",
          "subscribed_events",
          "active",
          "endpoint",
          "webhook_secret"
        ]
      },
      "WebhookList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Webhook"
            },
            "description": "Array of webhook objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of webhooks matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "WebhookEvents": {
        "type": "string",
        "enum": [
          "describe.job.processing",
          "describe.job.completed",
          "describe.job.failed",
          "extract.job.processing",
          "extract.job.completed",
          "extract.job.failed",
          "file.job.processing",
          "file.job.completed",
          "file.job.failed",
          "file.job.deleted",
          "collection.file.job.processing",
          "collection.file.job.completed",
          "collection.file.job.failed",
          "collection.file.job.deleted",
          "segment.job.processing",
          "segment.job.completed",
          "segment.job.failed"
        ],
        "description": "Webhook events that can be subscribed to"
      },
      "WebhookDeleteResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for the webhook"
          },
          "object": {
            "type": "string",
            "enum": ["webhook"],
            "description": "Object type, always 'webhook'"
          }
        },
        "required": ["id", "object"]
      },
      "WebhookCreateRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "Description of the webhook"
          },
          "endpoint": {
            "type": "string",
            "description": "URL of the webhook endpoint"
          },
          "subscribed_events": {
            "type": "array",
            "description": "Events that the webhook is subscribed to",
            "items": {
              "$ref": "#/components/schemas/WebhookEvents"
            }
          }
        }
      },
      "WebhookUpdateRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "Description of the webhook"
          },
          "endpoint": {
            "type": "string",
            "description": "URL of the webhook endpoint"
          },
          "subscribed_events": {
            "type": "array",
            "description": "Events that the webhook is subscribed to",
            "items": {
              "$ref": "#/components/schemas/WebhookEvents"
            }
          },
          "active": {
            "type": "boolean",
            "description": "Whether the webhook is active"
          }
        }
      },
      "CollectionEntitiesList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "file_id": {
                  "type": "string",
                  "description": "ID of the file"
                },
                "data": {
                  "type": "object",
                  "properties": {
                    "entities": {
                      "type": "object",
                      "description": "Entities extracted from the file at the video level"
                    },
                    "segment_entities": {
                      "type": "array",
                      "description": "Array of video entities extracted from individual time segments",
                      "items": {
                        "type": "object",
                        "properties": {
                          "start_time": {
                            "type": "number",
                            "description": "Start time of the segment in seconds"
                          },
                          "end_time": {
                            "type": "number",
                            "description": "End time of the segment in seconds"
                          },
                          "entities": {
                            "type": "object",
                            "description": "Entities extracted from the segment"
                          }
                        }
                      }
                    }
                  },
                  "required": ["entities"]
                }
              },
              "required": ["file_id", "data"]
            },
            "description": "Array of file entities"
          },
          "total": {
            "type": "integer",
            "description": "Total number of files with entities matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "CollectionRichTranscriptsList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "file_id": {
                  "type": "string",
                  "description": "ID of the file"
                },
                "duration_seconds": {
                  "type": "number",
                  "description": "Duration of the video in seconds"
                },
                "data": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "description": "Content string returned based on formatting, e.g. set to markdown text when response_format=markdown is requested"
                        },
                        "title": {
                          "type": "string",
                          "description": "Generated title of the video"
                        },
                        "summary": {
                          "type": "string",
                          "description": "Generated video level summary"
                        },
                        "segment_summary": {
                          "type": "array",
                          "description": "Array of summary information for each segment of the video. Only available when enable_summary is set to true in the transcribe configuration.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "title": {
                                "type": "string",
                                "description": "Generated segment-level title"
                              },
                              "summary": {
                                "type": "string",
                                "description": "Generated segment-level summary"
                              },
                              "start_time": {
                                "type": "number",
                                "description": "Start time of segment in seconds"
                              },
                              "end_time": {
                                "type": "number",
                                "description": "End time of segment in seconds"
                              }
                            }
                          }
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/DescribeOutput"
                    }
                  ]
                }
              },
              "required": ["file_id", "data"]
            },
            "description": "Array of rich transcription data"
          },
          "total": {
            "type": "integer",
            "description": "Total number of files with rich transcription data matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "CollectionMediaDescriptionsList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "file_id": {
                  "type": "string",
                  "description": "Unique identifier for the file"
                },
                "added_at": {
                  "type": "integer",
                  "description": "Unix timestamp in milliseconds when the file was added to the collection"
                },
                "object": {
                  "type": "string",
                  "enum": ["collection_file"],
                  "description": "Object type, always 'collection_file'"
                },
                "duration_seconds": {
                  "type": "number",
                  "description": "Duration of the video in seconds"
                },
                "data": {
                  "allOf": [
                    {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "description": "Content string returned based on formatting, e.g. set to markdown text when response_format=markdown is requested"
                        },
                        "title": {
                          "type": "string",
                          "description": "Generated title of the video"
                        },
                        "summary": {
                          "type": "string",
                          "description": "Generated video level summary"
                        },
                        "segment_summary": {
                          "type": "array",
                          "description": "Array of summary information for each segment of the video",
                          "items": {
                            "type": "object",
                            "properties": {
                              "title": {
                                "type": "string",
                                "description": "Generated segment-level title"
                              },
                              "summary": {
                                "type": "string",
                                "description": "Generated segment-level summary"
                              },
                              "start_time": {
                                "type": "number",
                                "description": "Start time of segment in seconds"
                              },
                              "end_time": {
                                "type": "number",
                                "description": "End time of segment in seconds"
                              }
                            }
                          }
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/DescribeOutput"
                    }
                  ]
                }
              },
              "required": ["file_id", "data", "added_at", "object"]
            },
            "description": "Array of media description data"
          },
          "total": {
            "type": "integer",
            "description": "Total number of files with media description data matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "SegmentationUniformConfig": {
        "type": "object",
        "required": ["window_seconds"],
        "properties": {
          "window_seconds": {
            "type": "number",
            "minimum": 1,
            "maximum": 120,
            "description": "The duration of each segment in seconds. Must be between 1 and 120 seconds."
          },
          "hop_seconds": {
            "type": "number",
            "minimum": 1,
            "maximum": 120,
            "description": "The offset between the start of new windows. This means there can be overlap between segments. If not provided, defaults to window_seconds. Must be between 1 and 120 seconds."
          }
        }
      },
      "SegmentationShotDetectorConfig": {
        "type": "object",
        "required": ["detector"],
        "properties": {
          "threshold": {
            "type": "number",
            "nullable": true,
            "description": "Detection sensitivity threshold - lower values create more segments:\n\n\u2022 **content**: Sensitivity to visual differences (default: 27.0). Lower values detect smaller changes in color/lighting.\n\u2022 **adaptive**: Does not support threshold parameter - uses internal adaptive algorithm."
          },
          "min_seconds": {
            "type": "number",
            "minimum": 1,
            "maximum": 120,
            "nullable": true,
            "description": "The minimum length of a shot in seconds. Must be between 1 and 120 seconds."
          },
          "max_seconds": {
            "type": "number",
            "minimum": 1,
            "maximum": 120,
            "nullable": true,
            "description": "The maximum length of a shot in seconds. Must be between 1 and 120 seconds."
          },
          "detector": {
            "type": "string",
            "enum": ["adaptive", "content"],
            "description": "The detector strategy to use:\n\n\u2022 **adaptive**: Designed for dynamic footage with camera movement, panning, or action. Examples: sports broadcasts, drone footage, handheld documentaries, action movies, live events.\n\u2022 **content**: Optimized for controlled footage with clear visual transitions. Examples: studio interviews, corporate videos, educational content, product demos, scripted content."
          }
        }
      },
      "KeyframeConfig": {
        "type": "object",
        "required": ["frames_per_segment"],
        "description": "Configuration for keyframe extraction. When provided, will be used to extract keyframes for the segmentation. This is not supported for YouTube videos.",
        "properties": {
          "frames_per_segment": {
            "type": "number",
            "minimum": 0,
            "maximum": 8,
            "description": "The number of key frames to extract per segment"
          },
          "max_width": {
            "type": "number",
            "minimum": 144,
            "maximum": 4320,
            "default": 280,
            "description": "The maximum width of the key frames in pixels"
          }
        }
      },
      "SegmentationManualConfig": {
        "type": "object",
        "required": ["segments"],
        "properties": {
          "segments": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "start_time": {
                  "type": "number",
                  "description": "The start time of the segment in seconds"
                },
                "end_time": {
                  "type": "number",
                  "description": "The end time of the segment in seconds"
                }
              }
            },
            "description": "Array of segments"
          }
        }
      },
      "SegmentationConfig": {
        "type": "object",
        "description": "Configuration for video segmentation. **Choose a strategy and provide ONLY the corresponding config:**\n\n\u2022 **uniform**: Provide `uniform_config`, do NOT provide other configs\n\u2022 **shot-detector**: Provide `shot_detector_config`, do NOT provide other configs\n\u2022 **manual**: Provide `manual_config`, do NOT provide other configs\n\u2022 **narrative**: Provide `narrative_config`, do NOT provide other configs\n\nOptionally specify `start_time_seconds` and `end_time_seconds` to limit segmentation to a portion of the video.",
        "required": ["strategy"],
        "properties": {
          "strategy": {
            "type": "string",
            "enum": ["uniform", "shot-detector", "manual", "narrative"],
            "description": "Segmentation strategy - determines which config you must provide"
          },
          "uniform_config": {
            "$ref": "#/components/schemas/SegmentationUniformConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'uniform'** - Configuration for uniform segmentation."
          },
          "shot_detector_config": {
            "$ref": "#/components/schemas/SegmentationShotDetectorConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'shot-detector'** - Configuration for shot detection segmentation."
          },
          "manual_config": {
            "$ref": "#/components/schemas/SegmentationManualConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'manual'** - Configuration for manual segmentation."
          },
          "narrative_config": {
            "$ref": "#/components/schemas/NarrativeConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'narrative'** - Configuration for narrative-based chapter segmentation using AI analysis."
          },
          "keyframe_config": {
            "$ref": "#/components/schemas/KeyframeConfig",
            "description": "When provided, will be used to extract keyframes for the segmentation."
          },
          "start_time_seconds": {
            "type": "number",
            "minimum": 0,
            "description": "Optional: The start time of the video in seconds to start segmenting from"
          },
          "end_time_seconds": {
            "type": "number",
            "minimum": 0,
            "description": "Optional: The end time of the video in seconds to stop segmenting at"
          }
        }
      },
      "DefaultSegmentationConfig": {
        "type": "object",
        "description": "Configuration for video segmentation. **Choose a strategy and provide ONLY the corresponding config:**\n\n\u2022 **uniform**: Provide `uniform_config`, do NOT provide other configs\n\u2022 **shot-detector**: Provide `shot_detector_config`, do NOT provide other configs\n\u2022 **narrative**: Provide `narrative_config`, do NOT provide other configs\n\nOptionally specify `start_time_seconds` and `end_time_seconds` to limit segmentation to a portion of the video.",
        "required": ["strategy"],
        "properties": {
          "strategy": {
            "type": "string",
            "enum": ["uniform", "shot-detector", "narrative"],
            "description": "Segmentation strategy - determines which config you must provide. Manual strategies are not supported for default segmentation configs."
          },
          "uniform_config": {
            "$ref": "#/components/schemas/SegmentationUniformConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'uniform'** - Configuration for uniform segmentation."
          },
          "shot_detector_config": {
            "$ref": "#/components/schemas/SegmentationShotDetectorConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'shot-detector'** - Configuration for shot detection segmentation."
          },
          "narrative_config": {
            "$ref": "#/components/schemas/NarrativeConfig",
            "description": "\ud83c\udfaf **REQUIRED when strategy = 'narrative'** - Configuration for narrative-based chapter segmentation using AI analysis."
          },
          "keyframe_config": {
            "$ref": "#/components/schemas/KeyframeConfig",
            "description": "When provided, will be used to extract keyframes for the segmentation."
          },
          "start_time_seconds": {
            "type": "number",
            "minimum": 0,
            "description": "Optional: The start time of the video in seconds to start segmenting from"
          },
          "end_time_seconds": {
            "type": "number",
            "minimum": 0,
            "description": "Optional: The end time of the video in seconds to stop segmenting at"
          }
        }
      },
      "ThumbnailsConfig": {
        "type": "object",
        "required": ["enable_segment_thumbnails"],
        "properties": {
          "enable_segment_thumbnails": {
            "type": "boolean",
            "description": "Whether to enable segment thumbnails. If not provided will use default to false. Cannot be used together with segmentation_id."
          }
        }
      },
      "FileSegmentationConfig": {
        "type": "object",
        "properties": {
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "Segmentation job id to use. If not provided will use default to uniform 20s segmentation. Cannot be provided together with segmentation_config."
          },
          "segmentation_config": {
            "$ref": "#/components/schemas/SegmentationConfig",
            "description": "Configuration for video segmentation. Cannot be provided together with segmentation_id."
          }
        }
      },
      "Segmentation": {
        "type": "object",
        "required": [
          "segmentation_id",
          "status",
          "created_at",
          "file_id",
          "segmentation_config",
          "thumbnails_config"
        ],
        "properties": {
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the segmentation job"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ],
            "description": "Status of the segmentation job. If a job has the status 'not_applicable' it means that we were unable to find any appropriate scenes for this video. This can be possible if you use the shot-detector strategy."
          },
          "created_at": {
            "type": "number",
            "minimum": 0,
            "description": "Unix timestamp in milliseconds when the segmentation was created"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file this segmentation belongs to"
          },
          "segmentation_config": {
            "$ref": "#/components/schemas/SegmentationConfig"
          },
          "thumbnails_config": {
            "$ref": "#/components/schemas/ThumbnailsConfig"
          },
          "total_segments": {
            "type": "number",
            "minimum": 0,
            "description": "Total number of segments in this segmentation (only present when status is completed)"
          },
          "total_shots": {
            "type": "number",
            "minimum": 0,
            "description": "Total number of shots in this segmentation (only present when status is completed and segmentation_config.strategy is 'shot-detector')"
          },
          "total_chapters": {
            "type": "number",
            "minimum": 0,
            "description": "Total number of chapters in this segmentation (only present when status is completed and segmentation_config.strategy is 'narrative')"
          },
          "data": {
            "type": "object",
            "description": "Segment data with pagination (only present when status is completed and segments exist)",
            "required": ["object", "total", "limit", "offset"],
            "properties": {
              "object": {
                "type": "string",
                "enum": ["list"],
                "description": "Object type, always 'list'"
              },
              "segments": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["id", "start_time", "end_time"],
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Unique identifier for the segment"
                    },
                    "start_time": {
                      "type": "number",
                      "description": "Start time of the segment in seconds"
                    },
                    "end_time": {
                      "type": "number",
                      "description": "End time of the segment in seconds"
                    },
                    "thumbnail_url": {
                      "type": "string",
                      "description": "URL of the thumbnail for the segment if it exists"
                    }
                  }
                }
              },
              "shots": {
                "type": "array",
                "description": "Array of shots in the original video (only present when status is completed and segmentation_config.strategy is 'shot-detector')",
                "items": {
                  "$ref": "#/components/schemas/Shot"
                }
              },
              "chapters": {
                "type": "array",
                "description": "Array of narrative chapters in the video (only present when status is completed and segmentation_config.strategy is 'narrative')",
                "items": {
                  "$ref": "#/components/schemas/Chapter"
                }
              },
              "total": {
                "type": "integer",
                "description": "Total number of segments"
              },
              "limit": {
                "type": "integer",
                "description": "Number of segments returned in this response"
              },
              "offset": {
                "type": "integer",
                "description": "Offset from the start of the segments list"
              }
            }
          }
        }
      },
      "SegmentationListItem": {
        "type": "object",
        "required": [
          "segmentation_id",
          "status",
          "created_at",
          "file_id",
          "segmentation_config",
          "thumbnails_config"
        ],
        "properties": {
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the segmentation job"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed",
              "not_applicable"
            ],
            "description": "Status of the segmentation job. If a job has the status 'not_applicable' it means that we were unable to find any appropriate scenes for this video. This can be possible if you use the shot-detector strategy."
          },
          "created_at": {
            "type": "number",
            "minimum": 0,
            "description": "Unix timestamp in milliseconds when the segmentation was created"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file this segmentation belongs to"
          },
          "segmentation_config": {
            "$ref": "#/components/schemas/SegmentationConfig"
          },
          "thumbnails_config": {
            "$ref": "#/components/schemas/ThumbnailsConfig"
          },
          "total_segments": {
            "type": "number",
            "minimum": 0,
            "description": "Total number of segments in this segmentation (only present when status is completed)"
          }
        },
        "description": "Segmentation object as returned in list responses (does not include segments array or data property)"
      },
      "SegmentationList": {
        "type": "object",
        "required": ["object", "data", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentationListItem"
            },
            "description": "Array of segmentation objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of segmentations matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        }
      },
      "FrameExtractionConfig": {
        "type": "object",
        "description": "Configuration for frame extraction. Currently only supports uniform strategy.",
        "required": ["strategy"],
        "properties": {
          "strategy": {
            "type": "string",
            "enum": ["uniform"],
            "description": "Frame extraction strategy - currently only 'uniform' is supported"
          },
          "uniform_config": {
            "$ref": "#/components/schemas/FrameExtractionUniformConfig",
            "description": "Configuration for uniform frame extraction"
          },
          "thumbnails_config": {
            "$ref": "#/components/schemas/FrameExtractionThumbnailsConfig",
            "description": "Configuration for frame thumbnails. Optional."
          },
          "start_time_seconds": {
            "type": "number",
            "minimum": 0,
            "description": "Optional: The start time of the video in seconds to start extracting frames from"
          },
          "end_time_seconds": {
            "type": "number",
            "minimum": 0,
            "description": "Optional: The end time of the video in seconds to stop extracting frames at"
          }
        }
      },
      "FrameExtractionUniformConfig": {
        "type": "object",
        "description": "Configuration for uniform frame extraction",
        "properties": {
          "frames_per_second": {
            "type": "number",
            "minimum": 0.1,
            "maximum": 30,
            "default": 1,
            "description": "Number of frames to extract per second of video"
          },
          "max_width": {
            "type": "number",
            "minimum": 64,
            "maximum": 4096,
            "default": 1024,
            "description": "Maximum width of extracted frames in pixels. Aspect ratio is preserved."
          }
        }
      },
      "FrameExtractionThumbnailsConfig": {
        "type": "object",
        "description": "Configuration for frame thumbnails",
        "properties": {
          "enable_frame_thumbnails": {
            "type": "boolean",
            "default": true,
            "description": "Whether to generate CDN-hosted thumbnails for extracted frames"
          }
        }
      },
      "FrameExtraction": {
        "type": "object",
        "required": [
          "frame_extraction_id",
          "status",
          "created_at",
          "file_id",
          "frame_extraction_config"
        ],
        "properties": {
          "frame_extraction_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the frame extraction job"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "processing", "completed", "failed"],
            "description": "Status of the frame extraction job"
          },
          "created_at": {
            "type": "number",
            "minimum": 0,
            "description": "Unix timestamp in milliseconds when the frame extraction was created"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file this frame extraction belongs to"
          },
          "frame_extraction_config": {
            "$ref": "#/components/schemas/FrameExtractionConfig"
          },
          "frame_count": {
            "type": "number",
            "minimum": 0,
            "description": "Total number of frames extracted (only present when status is completed)"
          },
          "data": {
            "type": "object",
            "description": "Frame data with pagination (only present when status is completed and frames exist)",
            "required": ["object", "total", "limit", "offset"],
            "properties": {
              "object": {
                "type": "string",
                "enum": ["list"],
                "description": "Object type, always 'list'"
              },
              "frames": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["id", "timestamp"],
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Unique identifier for the frame"
                    },
                    "timestamp": {
                      "type": "number",
                      "description": "Timestamp of the frame in seconds"
                    },
                    "thumbnail_url": {
                      "type": "string",
                      "description": "URL of the CDN-hosted thumbnail for the frame if thumbnails are enabled"
                    }
                  }
                },
                "description": "Array of extracted frames"
              },
              "total": {
                "type": "integer",
                "description": "Total number of frames in this extraction"
              },
              "limit": {
                "type": "integer",
                "description": "Number of frames returned in this response"
              },
              "offset": {
                "type": "integer",
                "description": "Offset from the start of the frames list"
              }
            }
          }
        }
      },
      "FrameExtractionList": {
        "type": "object",
        "required": ["object", "data", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "frame_extraction_id",
                "status",
                "created_at",
                "file_id",
                "frame_extraction_config"
              ],
              "properties": {
                "frame_extraction_id": {
                  "type": "string",
                  "format": "uuid",
                  "description": "Unique identifier for the frame extraction job"
                },
                "status": {
                  "type": "string",
                  "enum": ["pending", "processing", "completed", "failed"],
                  "description": "Status of the frame extraction job"
                },
                "created_at": {
                  "type": "number",
                  "minimum": 0,
                  "description": "Unix timestamp in milliseconds when the frame extraction was created"
                },
                "file_id": {
                  "type": "string",
                  "format": "uuid",
                  "description": "ID of the file this frame extraction belongs to"
                },
                "frame_extraction_config": {
                  "$ref": "#/components/schemas/FrameExtractionConfig"
                },
                "frame_count": {
                  "type": "number",
                  "minimum": 0,
                  "description": "Total number of frames extracted (only present when status is completed)"
                }
              }
            },
            "description": "Array of frame extraction objects"
          },
          "total": {
            "type": "integer",
            "description": "Total number of frame extractions matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        }
      },
      "SearchRequest": {
        "type": "object",
        "properties": {
          "scope": {
            "type": "string",
            "enum": ["file", "segment", "face"],
            "description": "Search scope - 'file' searches at file level (requires collections with enable_summary=true), 'segment' searches at segment level, 'face' searches for faces in videos using image matching"
          },
          "collections": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "minItems": 1,
            "description": "List of collection IDs to search within. \n\nFor text search (scope='file' or 'segment'): All collections must be of collection_type 'media-descriptions' or 'rich-transcripts'. For file-level search, collections must have 'enable_summary: true' in transcribe_config.\n\nFor face search (scope='face'): All collections must be of collection_type 'face-analysis'."
          },
          "query": {
            "type": "string",
            "minLength": 1,
            "description": "Text search query to find relevant content (required for scope='file' or 'segment')"
          },
          "source_image": {
            "type": "object",
            "description": "Source image for face search (required for scope='face')",
            "properties": {
              "url": {
                "type": "string",
                "description": "URL of the source image to search for"
              },
              "base64": {
                "type": "string",
                "description": "Base64-encoded image bytes"
              }
            }
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "default": 10,
            "description": "Maximum number of search results to return (applies to total items across groups when grouping)"
          },
          "filter": {
            "$ref": "#/components/schemas/SearchFilter"
          },
          "threshold": {
            "type": "number",
            "description": "Minimum score threshold to filter results. Can be any real number."
          },
          "group_by_key": {
            "type": "string",
            "enum": ["file"],
            "description": "Group results by file. Cannot be used with scope=\"file\". When specified, results are grouped by file_id."
          },
          "sort_by": {
            "type": "string",
            "enum": ["score", "item_count"],
            "default": "score",
            "description": "Sort order for results. Default: \"score\". When group_by_key is specified, can also use \"item_count\" to sort by number of items per group."
          },
          "search_modalities": {
            "$ref": "#/components/schemas/SearchModalities"
          },
          "label_filters": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Filter eligible search items by presence of one or more labels in the provided list (otherwise all tags will be considered in search response). Only supported for `tag_semantic` and `tag_lexical` search modalities "
          }
        }
      },
      "SearchFilter": {
        "type": "object",
        "properties": {
          "metadata": {
            "type": "array",
            "description": "Filter by file metadata using JSON path expressions",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchFilterCriteria"
                },
                {
                  "type": "object",
                  "properties": {
                    "scope": {
                      "type": "string",
                      "enum": ["file", "segment"],
                      "default": "file",
                      "description": "Specifies scope of eligible search items (file/segment) to check metadata filtering conditions"
                    }
                  }
                }
              ]
            }
          },
          "video_info": {
            "type": "array",
            "description": "Filter by video information",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchFilterCriteria"
                },
                {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "enum": ["duration_seconds", "has_audio"]
                    }
                  }
                }
              ]
            }
          },
          "file": {
            "type": "array",
            "description": "Filter by file properties",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchFilterCriteria"
                },
                {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "enum": ["bytes", "filename", "uri", "created_at", "id"]
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "SearchFilterCriteria": {
        "type": "object",
        "required": ["path", "operator"],
        "properties": {
          "path": {
            "type": "string",
            "description": "JSON path for the field to filter on"
          },
          "operator": {
            "type": "string",
            "enum": [
              "NotEqual",
              "Equal",
              "LessThan",
              "GreaterThan",
              "ContainsAny",
              "ContainsAll",
              "In",
              "Like"
            ],
            "description": "Comparison operator to apply"
          },
          "valueText": {
            "type": "string",
            "description": "Text value for scalar comparison (used with NotEqual, Equal, LessThan, GreaterThan, Like)"
          },
          "valueTextArray": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Array of values for array comparisons (used with ContainsAny, ContainsAll, In)"
          }
        }
      },
      "SearchResponseList": {
        "type": "object",
        "required": ["object", "data", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "id",
                "object",
                "scope",
                "results",
                "total",
                "limit"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid",
                  "description": "ID of the search response"
                },
                "object": {
                  "type": "string",
                  "enum": ["search"],
                  "description": "Object type, always 'search'"
                },
                "query": {
                  "type": "string",
                  "description": "The search query that was executed (for text search) or the source image URL/base64 indicator (for face search)"
                },
                "scope": {
                  "type": "string",
                  "enum": ["file", "segment", "face"],
                  "description": "The search scope that was used"
                },
                "group_by_key": {
                  "type": "string",
                  "enum": ["file"],
                  "description": "The key used for grouping results. Only present when group_by_key was specified in the request and results are grouped."
                },
                "group_count": {
                  "type": "integer",
                  "description": "Number of groups in the results. Only present when group_by_key is specified."
                },
                "search_modalities": {
                  "$ref": "#/components/schemas/SearchModalities"
                },
                "total": {
                  "type": "integer",
                  "description": "Total number of results returned. When group_by_key is specified, this represents the total number of items across all groups (not the number of groups)."
                },
                "limit": {
                  "type": "integer",
                  "description": "The limit that was applied to the search"
                }
              }
            }
          },
          "total": {
            "type": "integer",
            "description": "Total number of search responses matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        }
      },
      "SearchResponse": {
        "type": "object",
        "required": ["id", "object", "scope", "results", "total", "limit"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the search response"
          },
          "object": {
            "type": "string",
            "enum": ["search"],
            "description": "Object type, always 'search'"
          },
          "query": {
            "type": "string",
            "description": "The search query that was executed (for text search) or the source image URL/base64 indicator (for face search)"
          },
          "scope": {
            "type": "string",
            "enum": ["file", "segment", "face"],
            "description": "The search scope that was used"
          },
          "group_by_key": {
            "type": "string",
            "enum": ["file"],
            "description": "The key used for grouping results. Only present when group_by_key was specified in the request and results are grouped."
          },
          "group_count": {
            "type": "integer",
            "description": "Number of groups in the results. Only present when group_by_key is specified."
          },
          "search_modalities": {
            "$ref": "#/components/schemas/SearchModalities"
          },
          "results": {
            "type": "array",
            "description": "Array of search results ranked by relevance score",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/FileSearchResult"
                },
                {
                  "$ref": "#/components/schemas/SegmentSearchResult"
                },
                {
                  "$ref": "#/components/schemas/FaceSearchResult"
                },
                {
                  "$ref": "#/components/schemas/SegmentGroupResult"
                },
                {
                  "$ref": "#/components/schemas/FaceGroupResult"
                }
              ]
            }
          },
          "total": {
            "type": "integer",
            "description": "Total number of results returned. When group_by_key is specified, this represents the total number of items across all groups (not the number of groups)."
          },
          "limit": {
            "type": "integer",
            "description": "The limit that was applied to the search"
          }
        }
      },
      "FileSearchResult": {
        "type": "object",
        "required": ["type", "file_id", "collection_id", "score", "id"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["file"],
            "description": "Result type, always 'file'"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file"
          },
          "collection_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the collection containing this file"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the search document"
          },
          "score": {
            "type": "number",
            "description": "Relevance score (higher is more relevant)"
          },
          "filename": {
            "type": "string",
            "nullable": true,
            "description": "Original filename of the video"
          },
          "summary": {
            "type": "string",
            "nullable": true,
            "description": "Generated summary of the video"
          },
          "generated_title": {
            "type": "string",
            "nullable": true,
            "description": "Generated title of the video"
          },
          "thumbnail_url": {
            "type": "string",
            "format": "uri",
            "description": "URL of the thumbnail for the file if available."
          },
          "tag": {
            "$ref": "#/components/schemas/SearchTagResponse"
          }
        }
      },
      "SegmentSearchResult": {
        "type": "object",
        "required": [
          "type",
          "file_id",
          "collection_id",
          "segment_id",
          "score",
          "id",
          "start_time",
          "end_time"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["segment"],
            "description": "Result type, always 'segment'"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file"
          },
          "collection_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the collection containing this file"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the segment"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the search document"
          },
          "score": {
            "type": "number",
            "description": "Relevance score (higher is more relevant)"
          },
          "start_time": {
            "type": "number",
            "description": "Start time of the segment in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "End time of the segment in seconds"
          },
          "title": {
            "type": "string",
            "nullable": true,
            "description": "Title associated with the segment"
          },
          "filename": {
            "type": "string",
            "nullable": true,
            "description": "Original filename of the video"
          },
          "visual_description": {
            "type": "array",
            "description": "Visual descriptions for the segment",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "description": "Description of visual content in the segment"
                },
                "start_time": {
                  "type": "number",
                  "description": "Start time of the visual content in seconds"
                },
                "end_time": {
                  "type": "number",
                  "description": "End time of the visual content in seconds"
                }
              }
            }
          },
          "scene_text": {
            "type": "array",
            "description": "Text detected on screen in the segment",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "description": "Text detected on screen"
                },
                "start_time": {
                  "type": "number",
                  "description": "Start time of the text in seconds"
                },
                "end_time": {
                  "type": "number",
                  "description": "End time of the text in seconds"
                }
              }
            }
          },
          "speech": {
            "type": "array",
            "description": "Speech transcription for the segment",
            "items": {
              "type": "object",
              "properties": {
                "speaker": {
                  "type": "string",
                  "description": "Identified speaker"
                },
                "text": {
                  "type": "string",
                  "description": "Transcribed speech text"
                },
                "start_time": {
                  "type": "number",
                  "description": "Start time of speech in seconds"
                },
                "end_time": {
                  "type": "number",
                  "description": "End time of speech in seconds"
                }
              }
            }
          },
          "thumbnail_url": {
            "type": "string",
            "format": "uri",
            "description": "URL of the thumbnail for the segment if available"
          },
          "tag": {
            "$ref": "#/components/schemas/SearchTagResponse"
          },
          "metadata": {
            "type": "object",
            "description": "User-provided metadata about the segment, if provided."
          },
          "keyframes": {
            "type": "array",
            "description": "Keyframes for the segment",
            "items": {
              "type": "object",
              "properties": {
                "time_in_seconds": {
                  "type": "number",
                  "description": "Time of the keyframe in seconds"
                },
                "thumbnail_url": {
                  "type": "string",
                  "format": "uri",
                  "description": "URL of the thumbnail for the keyframe"
                }
              }
            }
          }
        }
      },
      "FaceSearchResult": {
        "type": "object",
        "required": [
          "type",
          "file_id",
          "collection_id",
          "face_id",
          "frame_id",
          "score",
          "timestamp"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["face"],
            "description": "Result type, always 'face'"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file containing the matched face"
          },
          "collection_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the collection containing this file"
          },
          "face_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the detected face"
          },
          "frame_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the frame where the face was detected"
          },
          "score": {
            "type": "number",
            "description": "Similarity score (higher is more similar)"
          },
          "timestamp": {
            "type": "number",
            "minimum": 0,
            "description": "Timestamp of the frame in seconds"
          },
          "face_bounding_box": {
            "type": "object",
            "properties": {
              "height": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Height of the bounding box (normalized 0-1)"
              },
              "width": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Width of the bounding box (normalized 0-1)"
              },
              "top": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Top position of the bounding box (normalized 0-1)"
              },
              "left": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "Left position of the bounding box (normalized 0-1)"
              }
            },
            "required": ["height", "width", "top", "left"]
          },
          "thumbnail_url": {
            "type": "string",
            "description": "URL of the frame thumbnail"
          }
        }
      },
      "SegmentGroupResult": {
        "type": "object",
        "required": [
          "type",
          "matched_items",
          "file_id",
          "item_count",
          "best_score"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["segment_group"],
            "description": "Result type, always 'segment_group'"
          },
          "matched_items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentSearchResult"
            },
            "description": "Array of segment search results that belong to this file"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file that this group represents"
          },
          "item_count": {
            "type": "integer",
            "description": "Number of matched items in this group"
          },
          "best_score": {
            "type": "number",
            "description": "The highest score among all items in this group"
          }
        }
      },
      "FaceGroupResult": {
        "type": "object",
        "required": [
          "type",
          "matched_items",
          "file_id",
          "item_count",
          "best_score"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["face_group"],
            "description": "Result type, always 'face_group'"
          },
          "matched_items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FaceSearchResult"
            },
            "description": "Array of face search results that belong to this file"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file that this group represents"
          },
          "item_count": {
            "type": "integer",
            "description": "Number of matched items in this group"
          },
          "best_score": {
            "type": "number",
            "description": "The highest score among all items in this group"
          }
        }
      },
      "ThumbnailList": {
        "type": "object",
        "required": ["object", "total", "limit", "offset", "data"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "total": {
            "type": "integer",
            "description": "Total number of segmentations matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Thumbnail"
            }
          }
        }
      },
      "Thumbnail": {
        "type": "object",
        "required": ["id", "url", "time"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the thumbnail"
          },
          "url": {
            "type": "string",
            "description": "The URL of the thumbnail"
          },
          "time": {
            "type": "number",
            "description": "The time of the thumbnail in seconds relative to the start of the video"
          },
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segmentation if part of a segmentation job"
          },
          "type": {
            "$ref": "#/components/schemas/ThumbnailType"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segment if part of a segmentation job"
          }
        }
      },
      "NewSegments": {
        "type": "object",
        "required": ["url", "criteria"],
        "properties": {
          "url": {
            "type": "string",
            "description": "Input video or audio file URL. Supports URIs of files uploaded to Cloudglue Files endpoint, public HTTP URLs, YouTube URLs (narrative criteria only), and files which have been granted access to Cloudglue via data connectors.\n\n**\u26a0\ufe0f Important: YouTube URLs and audio files are ONLY supported for narrative-based segmentation.** Shot-based segmentation requires direct video file access and does not support YouTube URLs or audio files. For YouTube URLs and audio files with narrative segmentation, the 'balanced' strategy is automatically used regardless of the strategy field value. Other strategies will be rejected with an error. For files via our Data connectors, see our documentation on data connectors for setup information."
          },
          "criteria": {
            "type": "string",
            "enum": ["shot", "narrative"],
            "description": "Segmentation criteria:\n\u2022 **shot**: Detect scene changes and shot boundaries using computer vision (not supported for YouTube URLs or audio files)\n\u2022 **narrative**: Identify logical narrative segments and chapters using AI analysis (supports YouTube URLs and audio files)"
          },
          "shot_config": {
            "$ref": "#/components/schemas/ShotConfig",
            "description": "Configuration for shot-based segmentation. Only provide when criteria is 'shot'."
          },
          "narrative_config": {
            "$ref": "#/components/schemas/NarrativeConfig",
            "description": "Configuration for narrative-based segmentation. Only provide when criteria is 'narrative'."
          }
        }
      },
      "ShotConfig": {
        "type": "object",
        "properties": {
          "detector": {
            "type": "string",
            "enum": ["content", "adaptive"],
            "default": "adaptive",
            "description": "Detection algorithm:\n\u2022 **adaptive**: Designed for dynamic footage with camera movement and action (default)\n\u2022 **content**: Optimized for controlled footage with clear visual transitions"
          },
          "max_duration_seconds": {
            "type": "integer",
            "minimum": 1,
            "maximum": 3600,
            "default": 300,
            "description": "Maximum duration for each segment in seconds (1 second to 1 hour, default: 5 minutes)"
          },
          "min_duration_seconds": {
            "type": "integer",
            "minimum": 1,
            "maximum": 3600,
            "default": 1,
            "description": "Minimum duration for each segment in seconds (1 second to 1 hour, default: 1 second)"
          }
        }
      },
      "NarrativeConfig": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "description": "Optional custom prompt to guide the narrative segmentation analysis. This will be incorporated into the main segmentation prompt as additional guidance."
          },
          "strategy": {
            "type": "string",
            "enum": ["comprehensive", "balanced"],
            "default": "balanced",
            "description": "Narrative segmentation strategy:\n\n\u2022 **comprehensive**: Uses a VLM to deeply analyze logical segments of video. Only available for video files (not YouTube or audio).\n\n\u2022 **balanced** (default): Balanced analysis approach using multiple modalities. Supports YouTube URLs and audio files.\n\n**Note**: YouTube URLs and audio files automatically use the 'balanced' strategy regardless of the strategy field value. The 'comprehensive' strategy is not supported for YouTube URLs or audio files."
          },
          "number_of_chapters": {
            "type": "integer",
            "minimum": 1,
            "description": "Optional target number of chapters to generate. If provided, min_chapters and max_chapters will be calculated automatically if not specified. If only target is provided, the AI will attempt to generate exactly this number of chapters."
          },
          "min_chapters": {
            "type": "integer",
            "minimum": 1,
            "description": "Optional minimum number of chapters to generate. If provided along with number_of_chapters and max_chapters, validates that min <= number_of_chapters <= max. If only number_of_chapters is provided, min and max are calculated automatically."
          },
          "max_chapters": {
            "type": "integer",
            "minimum": 1,
            "description": "Optional maximum number of chapters to generate. If provided along with number_of_chapters and min_chapters, validates that min <= number_of_chapters <= max. If only number_of_chapters is provided, min and max are calculated automatically."
          }
        }
      },
      "Segments": {
        "type": "object",
        "required": [
          "file_id",
          "job_id",
          "object",
          "status",
          "criteria",
          "created_at"
        ],
        "properties": {
          "job_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the segment job"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file this segment belongs to"
          },
          "object": {
            "type": "string",
            "enum": ["segments"],
            "description": "Object type, always 'segments'"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "processing", "completed", "failed"],
            "description": "Current status of the segment job"
          },
          "criteria": {
            "type": "string",
            "enum": ["shot", "narrative"],
            "description": "Segment criteria used for this job"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "shot_config": {
            "$ref": "#/components/schemas/ShotConfig",
            "description": "Configuration used for shot-based segmentation (only present when criteria is 'shot')"
          },
          "narrative_config": {
            "$ref": "#/components/schemas/NarrativeConfig",
            "description": "Configuration used for narrative-based segmentation (only present when criteria is 'narrative')"
          },
          "total_segments": {
            "type": "integer",
            "minimum": 0,
            "description": "Total number of segments generated (only present when status is 'completed')"
          },
          "total_shots": {
            "type": "integer",
            "minimum": 0,
            "description": "Total number of shots in the original video (only present when criteria is 'shot')"
          },
          "total_chapters": {
            "type": "integer",
            "minimum": 0,
            "description": "Total number of chapters in the video (only present when criteria is 'narrative')"
          },
          "segments": {
            "type": "array",
            "description": "Array of generated segments (only present when status is 'completed')",
            "items": {
              "$ref": "#/components/schemas/Segment"
            }
          },
          "shots": {
            "type": "array",
            "description": "Array of shots in the original video (only present when criteria is 'shot')",
            "items": {
              "$ref": "#/components/schemas/Shot"
            }
          },
          "chapters": {
            "type": "array",
            "description": "Array of narrative chapters in the video (only present when criteria is 'narrative')",
            "items": {
              "$ref": "#/components/schemas/Chapter"
            }
          }
        }
      },
      "SegmentsListItem": {
        "type": "object",
        "required": [
          "file_id",
          "job_id",
          "object",
          "status",
          "criteria",
          "created_at"
        ],
        "properties": {
          "job_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the segment job"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the file this segment belongs to"
          },
          "object": {
            "type": "string",
            "enum": ["segments"],
            "description": "Object type, always 'segments'"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "processing", "completed", "failed"],
            "description": "Current status of the segment job"
          },
          "criteria": {
            "type": "string",
            "enum": ["shot", "narrative"],
            "description": "Segment criteria used for this job"
          },
          "created_at": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "shot_config": {
            "$ref": "#/components/schemas/ShotConfig",
            "description": "Configuration used for shot-based segmentation (only present when criteria is 'shot')"
          },
          "narrative_config": {
            "$ref": "#/components/schemas/NarrativeConfig",
            "description": "Configuration used for narrative-based segmentation (only present when criteria is 'narrative')"
          }
        },
        "description": "Segmentation job object as returned in list responses (does not include segments array or total_segments)"
      },
      "Segment": {
        "type": "object",
        "required": ["start_time", "end_time"],
        "properties": {
          "start_time": {
            "type": "number",
            "minimum": 0,
            "description": "Start time of the segment in seconds"
          },
          "end_time": {
            "type": "number",
            "minimum": 0,
            "description": "End time of the segment in seconds"
          },
          "description": {
            "type": "string",
            "description": "Optional description of the segment content (available for narrative segmentation)"
          },
          "thumbnail_url": {
            "type": "string",
            "format": "uri",
            "description": "Optional URL of the thumbnail for this segment"
          },
          "shot_index": {
            "type": "integer",
            "description": "Index of the shot in the original video segmentation. Only present when criteria is set to 'shot'"
          }
        }
      },
      "Shot": {
        "type": "object",
        "required": ["index", "start_time", "end_time"],
        "properties": {
          "index": {
            "type": "integer",
            "description": "Index of the shot in the original video"
          },
          "start_time": {
            "type": "number",
            "minimum": 0,
            "description": "Start time of the shot in seconds"
          },
          "end_time": {
            "type": "number",
            "minimum": 0,
            "description": "End time of the shot in seconds"
          }
        }
      },
      "Chapter": {
        "type": "object",
        "required": ["index", "start_time", "end_time", "description"],
        "properties": {
          "index": {
            "type": "integer",
            "description": "Index of the chapter in the video"
          },
          "start_time": {
            "type": "number",
            "minimum": 0,
            "description": "Start time of the chapter in seconds"
          },
          "end_time": {
            "type": "number",
            "minimum": 0,
            "description": "End time of the chapter in seconds"
          },
          "description": {
            "type": "string",
            "description": "AI-generated description of the chapter content"
          }
        }
      },
      "SegmentsList": {
        "type": "object",
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentsListItem"
            },
            "description": "Array of segmentation job objects (without segments array or total_segments)"
          },
          "total": {
            "type": "integer",
            "description": "Total number of segmentation jobs matching the query"
          },
          "limit": {
            "type": "integer",
            "description": "Number of items returned in this response"
          },
          "offset": {
            "type": "integer",
            "description": "Offset from the start of the list"
          }
        },
        "required": ["object", "data", "total", "limit", "offset"]
      },
      "FaceMatchRequest": {
        "type": "object",
        "required": ["source_image", "target_video_url"],
        "properties": {
          "source_image": {
            "$ref": "#/components/schemas/SourceImage",
            "description": "Source image containing the face to search for"
          },
          "target_video_url": {
            "type": "string",
            "description": "URL of the target video to search in"
          },
          "max_faces": {
            "type": "integer",
            "minimum": 1,
            "maximum": 4000,
            "default": 50,
            "description": "Maximum number of faces to return"
          },
          "face_detection_id": {
            "type": "string",
            "format": "uuid",
            "description": "Optional: Use previously analyzed face detections in video"
          },
          "frame_extraction_id": {
            "type": "string",
            "format": "uuid",
            "description": "Optional: Use previously extracted frames"
          },
          "frame_extraction_config": {
            "$ref": "#/components/schemas/FrameExtractionConfig",
            "description": "Optional: Frame extraction configuration"
          }
        }
      },
      "FaceMatch": {
        "type": "object",
        "required": ["face_match_id", "status", "created_at"],
        "properties": {
          "face_match_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the face match job"
          },
          "face_detection_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the face detection analysis used"
          },
          "frame_extraction_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the frame extraction used"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the target file"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "processing", "completed", "failed"],
            "description": "Status of the face match job"
          },
          "created_at": {
            "type": "number",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "source_face_bounding_box": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FaceBoundingBox"
              }
            ],
            "nullable": true,
            "description": "Bounding box of the source face in the source image (null when job is pending/processing)"
          },
          "data": {
            "type": "object",
            "description": "Face match results (only present when status is completed)",
            "properties": {
              "object": {
                "type": "string",
                "enum": ["list"],
                "description": "Object type, always 'list'"
              },
              "total": {
                "type": "integer",
                "description": "Total number of face matches found"
              },
              "limit": {
                "type": "integer",
                "minimum": 1,
                "maximum": 100,
                "description": "Number of face matches returned per page"
              },
              "offset": {
                "type": "integer",
                "minimum": 0,
                "description": "Offset from the start of the face matches list"
              },
              "faces_matches": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FaceMatchResult"
                },
                "description": "Array of face matches found"
              }
            }
          }
        }
      },
      "FaceDetectionRequest": {
        "type": "object",
        "required": ["url"],
        "properties": {
          "url": {
            "type": "string",
            "description": "URL of the target video to analyze"
          },
          "frame_extraction_id": {
            "type": "string",
            "format": "uuid",
            "description": "Optional: Use previously extracted frames"
          },
          "frame_extraction_config": {
            "$ref": "#/components/schemas/FrameExtractionConfig",
            "description": "Optional: Frame extraction configuration"
          }
        }
      },
      "FaceDetection": {
        "type": "object",
        "required": ["face_detection_id", "status", "created_at"],
        "properties": {
          "face_detection_id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the face detection job"
          },
          "frame_extraction_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the frame extraction used"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the target file"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "processing", "completed", "failed"],
            "description": "Status of the face detection job"
          },
          "created_at": {
            "type": "number",
            "description": "Unix timestamp in milliseconds when the job was created"
          },
          "data": {
            "type": "object",
            "description": "Face detection results (only present when status is completed)",
            "properties": {
              "object": {
                "type": "string",
                "enum": ["list"],
                "description": "Object type, always 'list'"
              },
              "total": {
                "type": "integer",
                "description": "Total number of faces detected"
              },
              "limit": {
                "type": "integer",
                "minimum": 1,
                "maximum": 100,
                "description": "Number of faces returned per page"
              },
              "offset": {
                "type": "integer",
                "minimum": 0,
                "description": "Offset from the start of the faces list"
              },
              "faces": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/DetectedFace"
                },
                "description": "Array of detected faces"
              }
            }
          }
        }
      },
      "SourceImage": {
        "type": "object",
        "description": "Source image configuration - either url or base64_image must be provided",
        "properties": {
          "url": {
            "type": "string",
            "description": "Public URL of the source image"
          },
          "base64_image": {
            "type": "string",
            "description": "Base64 encoded JPEG image data"
          }
        }
      },
      "FaceBoundingBox": {
        "type": "object",
        "required": ["height", "width", "top", "left"],
        "properties": {
          "height": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Height of the bounding box (normalized 0-1)"
          },
          "width": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Width of the bounding box (normalized 0-1)"
          },
          "top": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Top position of the bounding box (normalized 0-1)"
          },
          "left": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "Left position of the bounding box (normalized 0-1)"
          }
        }
      },
      "FaceMatchResult": {
        "type": "object",
        "required": [
          "id",
          "face_bounding_box",
          "similarity",
          "frame_id",
          "timestamp"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the face match result"
          },
          "face_bounding_box": {
            "$ref": "#/components/schemas/FaceBoundingBox",
            "description": "Bounding box of the matched face in the frame"
          },
          "similarity": {
            "type": "number",
            "minimum": 0,
            "maximum": 100,
            "description": "Similarity score between source face and detected face (0-100)"
          },
          "frame_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the frame where the match was found"
          },
          "timestamp": {
            "type": "number",
            "description": "Timestamp of the frame in seconds"
          },
          "thumbnail_url": {
            "type": "string",
            "description": "URL of the frame thumbnail (if frame extraction enabled thumbnails)"
          }
        }
      },
      "DetectedFace": {
        "type": "object",
        "required": ["id", "face_bounding_box", "frame_id", "timestamp"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the detected face"
          },
          "face_bounding_box": {
            "$ref": "#/components/schemas/FaceBoundingBox",
            "description": "Bounding box of the detected face in the frame"
          },
          "frame_id": {
            "type": "string",
            "format": "uuid",
            "description": "ID of the frame where the face was detected"
          },
          "timestamp": {
            "type": "number",
            "description": "Timestamp of the frame in seconds"
          },
          "thumbnail_url": {
            "type": "string",
            "description": "URL of the frame thumbnail (if frame extraction enabled thumbnails)"
          }
        }
      },
      "SearchModalities": {
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "general_content",
            "speech_lexical",
            "ocr_lexical",
            "tag_semantic",
            "tag_lexical"
          ]
        },
        "maxItems": 5,
        "description": "Specifies the type(s) of search to execute. When multiple modalities are specified, a hybrid search is executed that combines results from each modality.\n\nAvailable modalities:\n- `general_content`: baseline for matching the content of the search item (file/segment) based on visual or spoken content similarity to provided short natural language query string\n- `speech_lexical`: performs keyword based search (e.g. query of `president` matching `president` or `presidential` strings) and exact match (e.g. specifically find mentions of `\"Barack Obama\"` or `\"Donald Trump\"`) against speech content present in search item\n- `ocr_lexical`: performs keyword based search and exact match against screen text content present in search item\n- `tag_semantic`: performs basic word semantic similarity search against tag values associated with search items (e.g. `query=animal` expected to match tags with value containing `dog` or `cat`)\n- `tag_lexical`: performs keyword based search and exact match against tag values associated with search items\n\nOnly applicable when search `scope=file` or `scope=segment`.\n"
      },
      "ThumbnailType": {
        "type": "string",
        "description": "The type of the thumbnail: 'segment' for segment thumbnails, 'keyframe' for keyframes, 'file' for file thumbnails, 'frame' for frame thumbnails. Comma separated string of one or more types."
      },
      "FileSegment": {
        "type": "object",
        "required": [
          "id",
          "file_id",
          "start_time",
          "end_time",
          "thumbnail_url"
        ],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segment"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file"
          },
          "start_time": {
            "type": "number",
            "description": "The start time of the segment in seconds"
          },
          "end_time": {
            "type": "number",
            "description": "The end time of the segment in seconds"
          },
          "thumbnail_url": {
            "type": "string",
            "description": "The URL of the thumbnail for the segment (if available)"
          },
          "metadata": {
            "type": "object",
            "description": "The user defined metadata for the segment"
          },
          "segmentation_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segmentation job it belongs to"
          }
        }
      },
      "PaginationResponse": {
        "type": "object",
        "required": ["object", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "total": {
            "type": "integer",
            "description": "The total number of items"
          },
          "limit": {
            "type": "integer",
            "description": "The number of items per page"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items"
          }
        }
      },
      "ListVideoTagsResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          {
            "properties": {
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/VideoTag"
                },
                "description": "The list of tags"
              }
            }
          }
        ]
      },
      "VideoTag": {
        "type": "object",
        "required": ["id", "label", "value", "type", "file_id"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the tag"
          },
          "label": {
            "type": "string",
            "description": "The label of the tag"
          },
          "value": {
            "type": "string",
            "description": "The value of the tag"
          },
          "type": {
            "type": "string",
            "enum": ["file", "segment"],
            "description": "The type of the tag"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segment"
          }
        }
      },
      "CreateVideoTagRequest": {
        "type": "object",
        "required": ["label", "value", "file_id"],
        "properties": {
          "label": {
            "type": "string",
            "description": "The label of the tag"
          },
          "value": {
            "type": "string",
            "description": "The value of the tag"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file"
          },
          "segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the segment"
          }
        }
      },
      "UpdateVideoTagRequest": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "description": "The label of the tag"
          },
          "value": {
            "type": "string",
            "description": "The value of the tag"
          }
        }
      },
      "SearchTagResponse": {
        "type": "object",
        "description": "The associated tag for the search result if it exists. Only provided for search requests with tag_semantic or tag_lexical search modalities.",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the tag"
          },
          "value": {
            "type": "string",
            "description": "The value of the tag"
          },
          "label": {
            "type": "string",
            "description": "The label of the tag"
          }
        }
      },
      "FaceMatchListResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          {
            "properties": {
              "data": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["job_id", "status", "created_at"],
                  "properties": {
                    "job_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Unique identifier for the face match job"
                    },
                    "face_detection_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the face detection analysis used"
                    },
                    "frame_extraction_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the frame extraction used"
                    },
                    "file_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the target file"
                    },
                    "status": {
                      "type": "string",
                      "enum": ["pending", "processing", "completed", "failed"],
                      "description": "Status of the face match job"
                    },
                    "created_at": {
                      "type": "number",
                      "description": "Unix timestamp in milliseconds when the job was created"
                    },
                    "source_face_bounding_box": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/FaceBoundingBox"
                        }
                      ],
                      "nullable": true,
                      "description": "Bounding box of the source face in the source image (null when job is pending/processing)"
                    },
                    "match_count": {
                      "type": "integer",
                      "description": "Number of matches found"
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "FaceDetectionListResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          {
            "properties": {
              "data": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["job_id", "status", "created_at"],
                  "properties": {
                    "job_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "Unique identifier for the face detection job"
                    },
                    "frame_extraction_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the frame extraction used"
                    },
                    "file_id": {
                      "type": "string",
                      "format": "uuid",
                      "description": "ID of the target file"
                    },
                    "status": {
                      "type": "string",
                      "enum": ["pending", "processing", "completed", "failed"],
                      "description": "Status of the face detection job"
                    },
                    "created_at": {
                      "type": "number",
                      "description": "Unix timestamp in milliseconds when the job was created"
                    },
                    "total_faces": {
                      "type": "integer",
                      "description": "Total number of faces detected"
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "ChatCompletionList": {
        "type": "object",
        "required": ["object", "data", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "id",
                "created_at",
                "object",
                "model",
                "usage",
                "choices",
                "payload"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid",
                  "description": "The ID of the chat completion"
                },
                "created_at": {
                  "type": "number",
                  "description": "The timestamp of the chat completion"
                },
                "object": {
                  "type": "string",
                  "enum": ["chat.completion"],
                  "description": "Object type, always 'chat.completion'"
                },
                "model": {
                  "type": "string",
                  "description": "The model used for the chat completion"
                },
                "usage": {
                  "type": "object",
                  "properties": {
                    "prompt_tokens": {
                      "type": "integer",
                      "description": "The number of tokens in the prompt"
                    },
                    "completion_tokens": {
                      "type": "integer",
                      "description": "The number of tokens in the completion"
                    },
                    "total_tokens": {
                      "type": "integer",
                      "description": "The total number of tokens in the request"
                    }
                  },
                  "description": "The usage of the chat completion"
                },
                "choices": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["index", "message"],
                    "properties": {
                      "index": {
                        "type": "integer",
                        "description": "The index of the choice"
                      },
                      "message": {
                        "$ref": "#/components/schemas/ChatMessage"
                      }
                    }
                  },
                  "description": "The choices of the chat completion"
                },
                "payload": {
                  "$ref": "#/components/schemas/ChatCompletionPayload"
                }
              }
            },
            "description": "The list of chat completions"
          },
          "total": {
            "type": "integer",
            "description": "The total number of items"
          },
          "limit": {
            "type": "integer",
            "description": "The number of items per page"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items"
          }
        }
      },
      "ChatCompletionPayload": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ChatMessage"
            }
          },
          "temperature": {
            "type": "number",
            "description": "The temperature of the chat completion"
          },
          "filter": {
            "$ref": "#/components/schemas/SearchFilter"
          },
          "collections": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            }
          }
        }
      },
      "FileSegmentListResponse": {
        "type": "object",
        "required": ["object", "data", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileSegment"
            }
          },
          "total": {
            "type": "integer",
            "description": "The total number of items"
          },
          "limit": {
            "type": "integer",
            "description": "The number of items per page"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items"
          }
        }
      },
      "ShareableAssetListResponse": {
        "type": "object",
        "required": ["object", "data", "total", "limit", "offset"],
        "properties": {
          "object": {
            "type": "string",
            "enum": ["list"],
            "description": "Object type, always 'list'"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShareableAsset"
            }
          },
          "total": {
            "type": "integer",
            "description": "The total number of items"
          },
          "limit": {
            "type": "integer",
            "description": "The number of items per page"
          },
          "offset": {
            "type": "integer",
            "description": "The offset of the items"
          }
        }
      },
      "ShareableAsset": {
        "type": "object",
        "required": ["id", "file_id", "url", "created_at"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier of the shareable asset"
          },
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file the shareable asset belongs to"
          },
          "file_segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file segment the shareable asset belongs to (optional)"
          },
          "title": {
            "type": "string",
            "description": "The title of the shareable asset"
          },
          "description": {
            "type": "string",
            "description": "The description of the shareable asset"
          },
          "metadata": {
            "type": "object",
            "description": "The metadata of the shareable asset"
          },
          "preview_url": {
            "type": "string",
            "description": "The thumbnail url of the shareable asset"
          },
          "media_download_url": {
            "type": "string",
            "description": "The signed media download url of the shareable asset"
          },
          "media_download_expires_at": {
            "type": "number",
            "nullable": true,
            "description": "The timestamp of when the media download url will expire"
          },
          "share_url": {
            "type": "string",
            "description": "This is the url that can be used to share the shareable asset"
          },
          "status": {
            "type": "string",
            "enum": ["pending", "processing", "completed", "failed"],
            "description": "The status of the shareable asset"
          },
          "asset_type": {
            "type": "string",
            "enum": ["file", "file_segment"],
            "description": "The type of asset the shareable asset belongs to"
          },
          "created_at": {
            "type": "number",
            "description": "The timestamp of when the shareable asset was created"
          },
          "object": {
            "type": "string",
            "enum": ["share"],
            "description": "Object type, always 'share'"
          }
        }
      },
      "CreateShareableAssetRequest": {
        "type": "object",
        "required": ["file_id"],
        "properties": {
          "file_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file the shareable asset will be created for"
          },
          "file_segment_id": {
            "type": "string",
            "format": "uuid",
            "description": "The ID of the file segment the shareable asset will be created for. When provided, the shareable asset will be created for the file segment."
          },
          "title": {
            "type": "string",
            "description": "The title of the shareable asset"
          },
          "description": {
            "type": "string",
            "description": "The description of the shareable asset"
          },
          "metadata": {
            "type": "object",
            "description": "The metadata of the shareable asset"
          }
        }
      },
      "UpdateShareableAssetRequest": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "description": "The title of the shareable asset"
          },
          "description": {
            "type": "string",
            "description": "The description of the shareable asset"
          },
          "metadata": {
            "type": "object",
            "description": "The metadata of the shareable asset"
          }
        }
      },
      "ModalitiesSchema": {
        "type": "array",
        "items": {
          "type": "string",
          "enum": [
            "speech",
            "visual_scene_description",
            "scene_text",
            "audio_description",
            "summary",
            "segment_summary",
            "title"
          ]
        },
        "description": "The modalities to output in the response. Can be used to return smaller data sets. Comma separated list of strings. Defaults to all modalities available / previously extracted. Accepted values are speech,visual_scene_description,scene_text, audio_description, summary, segment_summary, title"
      }
    },
    "securitySchemes": {
      "bearerAuth": {
        "type": "http",
        "scheme": "bearer"
      }
    }
  }
}
